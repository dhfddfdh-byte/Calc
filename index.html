<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Adopt Me Trade Calculator</title>
    <!-- Feature: Chart.js for History Graphs -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        :root {
            --bg: #0b1120;
            --panel: #161e2e;
            --card: #1e293b;
            --border: #334155;
            --text: #f1f5f9;
            --subtext: #94a3b8;
            --accent: #6366f1;
            --frost: #38bdf8;
            --win: #10b981;
            --lose: #ef4444;
            --trap: #f59e0b;
            --demand-color: #fbbf24;
            --rarity-legendary: #ff9800;
            --rarity-ultra: #f06292;
            --rarity-rare: #4fc3f7;
            --rarity-uncommon: #81c784;
            --rarity-common: #bdbdbd;
        }
        * { box-sizing: border-box; margin: 0; padding: 0; }
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
            background-color: var(--bg);
            color: var(--text);
            padding: 20px;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
        }
        .loading-screen {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: var(--bg); display: flex; flex-direction: column;
            align-items: center; justify-content: center; z-index: 9999;
        }
        .loading-spinner {
            width: 60px; height: 60px; border: 4px solid var(--border);
            border-top-color: var(--accent); border-radius: 50%;
            animation: spin 1s linear infinite;
        }
        @keyframes spin { to { transform: rotate(360deg); } }
        .loading-text { margin-top: 20px; font-size: 1.2em; color: var(--subtext); }
        .nav-bar {
            width: 100%;
            max-width: 1150px;
            display: flex;
            justify-content: flex-end;
            margin-bottom: 10px;
            gap: 10px;
        }
        .nav-btn {
            background: var(--panel);
            border: 1.5px solid var(--border);
            color: white;
            padding: 12px 24px;
            border-radius: 14px;
            cursor: pointer;
            font-weight: 800;
            transition: 0.2s;
        }
        .nav-btn:hover {
            border-color: var(--accent);
            background: var(--card);
        }
        .container {
    width: 100%; max-width: 1150px; display: flex; gap: 25px;
    flex-direction: row; margin-top: 40px;
    margin-bottom: 280px; 
}
        .trade-panel {
            flex: 1; background: var(--panel); border-radius: 24px;
            border: 1.5px solid var(--border); min-width: 340px; min-height: 520px;
        }
        .p-header {
            padding: 20px 25px; display: flex; justify-content: space-between;
            align-items: flex-start; border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .p-title { font-weight: 800; font-size: 1.25em; color: white; }
        
        .p-dem { 
            color: var(--demand-color); 
            font-size: 0.95em; 
            font-weight: 800; 
            margin-top: 4px; 
            display: block; 
            text-shadow: 0 0 10px rgba(251, 191, 36, 0.2);
        }
        .p-total { font-size: 1.6em; font-weight: 900; color: white; }
        .grid {
            padding: 20px; display: grid; grid-template-columns: repeat(auto-fill, minmax(105px, 1fr));
            gap: 15px;
        }
        .card {
            background: var(--card); border-radius: 14px; padding: 12px 8px;
            display: flex; flex-direction: column; align-items: center; position: relative;
            border: 1.5px solid transparent; transition: all 0.2s;
        }
        .card:hover { border-color: var(--accent); transform: translateY(-2px); }
        .card-img-container {
            width: 65px; height: 65px; display: flex; align-items: center;
            justify-content: center; margin-bottom: 5px; cursor: copy;
        }
        .card-img-container img { max-width: 100%; max-height: 100%; object-fit: contain; }
        .card-name {
            font-size: 0.7em; font-weight: 800; text-align: center; min-height: 2.4em;
            line-height: 1.2; color: #cbd5e1; overflow: visible; word-wrap: break-word;
            max-width: 100%;
        }
        .card-val { font-size: 0.95em; font-weight: 950; color: var(--frost); margin: 6px 0 2px 0; }
        .card-demand {
            font-size: 0.8em; font-weight: 800; color: var(--demand-color); margin-bottom: 4px;
        }
        .del {
            position: absolute; top: -6px; right: -6px; width: 22px; height: 22px;
            background: #ef4444; color: white; border-radius: 50%; display: flex;
            align-items: center; justify-content: center; font-size: 12px;
            cursor: pointer; z-index: 10; border: 2px solid var(--panel);
        }
        .toggles { display: flex; gap: 3px; }
        .t-btn {
            width: 20px; height: 20px; background: #0f172a; border-radius: 4px;
            font-size: 0.65em; font-weight: 900; color: #475569; cursor: pointer;
            display: flex; align-items: center; justify-content: center; transition: all 0.2s;
        }
        .t-btn.active { background: #3b82f6; color: white; }
        .lock-btn { position:absolute; bottom:26px; right:3px; background:#1e293b; border:1.5px solid #475569; color:#94a3b8; border-radius:7px; font-size:14px; padding:5px 7px; cursor:pointer; z-index:12; transition:0.15s; line-height:1; box-shadow:0 1px 4px rgba(0,0,0,0.4); }
        .lock-btn:hover { border-color:#f59e0b; color:#f59e0b; transform:scale(1.12); }
        .lock-btn.locked { background:#f59e0b22; border-color:#f59e0b; color:#f59e0b; box-shadow:0 0 7px #f59e0b55; }
        .card.pet-locked { opacity:0.6; }
        .card.pet-locked::after { content:'üîí'; position:absolute; top:50%; left:50%; transform:translate(-50%,-60%); font-size:1.4em; pointer-events:none; opacity:0.7; }
        .card-stack-badge {
            position: absolute; top: 5px; left: 5px; background: var(--accent);
            color: white; font-size: 0.75em; font-weight: 900; padding: 2px 8px;
            border-radius: 6px; z-index: 11; border: 1px solid var(--panel);
        }
        .plus {
            border: 2px dashed var(--border); border-radius: 14px; height: 150px;
            display: flex; align-items: center; justify-content: center; font-size: 2.5em;
            color: var(--border); cursor: pointer; transition: all 0.2s;
        }
        .plus:hover { border-color: var(--accent); color: var(--accent); }
        .verdict-box {
            position: fixed; bottom: 30px; background: var(--panel); width: 90%;
            max-width: 520px; padding: clamp(15px, 2.5vw, 25px); border-radius: 30px;
            border: 1px solid var(--border); text-align: center;
            box-shadow: 0 20px 50px rgba(0,0,0,0.7); z-index: 1000;
            left: 50%; transform: translateX(-50%);
        }
        .gauge-wrapper {
            width: 100%; height: 24px; background: #0f172a; border-radius: 12px; margin-bottom: 15px; position: relative; border: 1px solid var(--border); overflow: hidden;
        }
        
        .gauge-bar { width: 100%; height: 100%; background: linear-gradient(90deg, #ef4444 0%, #facc15 50%, #10b981 100%); }
        .gauge-bar.trap-active { background: repeating-linear-gradient(45deg, #b45309, #b45309 10px, #f59e0b 10px, #f59e0b 20px); }
        .gauge-needle {
            position: absolute; top: -2px; left: 50%; width: 4px; height: 28px; background: white; border: 1px solid black; transform: translateX(-50%); transition: left 0.4s cubic-bezier(0.34, 1.56, 0.64, 1); border-radius: 2px; z-index: 2; box-shadow: 0 0 10px rgba(0,0,0,0.5);
        }
        .v-text {
            font-size: clamp(2em, 8vw, 3.5em); font-weight: 950; line-height: 1; margin-bottom: 8px; letter-spacing: -2px;
        }
        .v-diff { font-weight: 800; font-size: clamp(0.9em, 3vw, 1.2em); margin-bottom: 5px; color: white; }
        .v-sub { color: var(--subtext); font-style: italic; font-size: clamp(0.75em, 2vw, 0.95em); margin-bottom: 18px; line-height: 1.4; padding: 0 10px; }
        .switches { display: inline-flex; background: #0f172a; padding: 5px; border-radius: 25px; align-items: center; gap: 10px; }
        .sw-btn { background: transparent; border: none; color: var(--subtext); padding: 8px 24px; border-radius: 20px; cursor: pointer; font-weight: 800; }
        .sw-btn.active { background: var(--accent); color: white; }
        .save-trade-btn { background: #334155; color: white; border: none; padding: 8px 16px; border-radius: 20px; cursor: pointer; font-weight: 700; font-size: 0.8em; margin-left: 5px; }
        .save-trade-btn:hover { background: var(--accent); }
        #graphOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.95); backdrop-filter: blur(12px); display: none; align-items: center; justify-content: center; z-index: 5500; }
        .graph-container { width: 95%; max-width: 800px; background: #1a2333; border-radius: 28px; border: 1px solid var(--border); display: flex; flex-direction: column; overflow: hidden; }
        .graph-header { padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: #111827; }
        .graph-body { padding: 30px; background: #0f172a; height: 400px; }
        #infoOverlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.97); backdrop-filter: blur(15px); display: none; align-items: center; justify-content: center; z-index: 6000; }
        .info-container { width: 95%; max-width: 600px; background: #1a2333; border-radius: 28px; border: 1px solid var(--border); box-shadow: 0 30px 70px rgba(0,0,0,0.8); overflow: hidden; }
        .info-header { padding: 20px; background: #111827; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .info-body { padding: 30px; overflow-y: auto; max-height: 70vh; color: #cbd5e1; line-height: 1.6; }
        .info-section { margin-bottom: 25px; }
        .info-section h4 { color: var(--accent); margin-bottom: 10px; font-weight: 900; text-transform: uppercase; font-size: 0.9em; letter-spacing: 1px; }
        .info-row { display: flex; justify-content: space-between; margin-bottom: 8px; padding-bottom: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); }
        .info-label { font-weight: 700; color: white; }
        .info-val { font-size: 0.9em; }
        .inv-suggest-container { padding: 15px; border-top: 1px solid rgba(255,255,255,0.05); background: rgba(99, 102, 241, 0.03); border-bottom-left-radius: 24px; border-bottom-right-radius: 24px; }
        .inv-suggest-title { font-size: 0.8em; font-weight: 900; color: var(--accent); text-transform: uppercase; margin-bottom: 10px; display: flex; align-items: center; gap: 5px; }
        .suggest-pill-row { display: flex; flex-direction: column; gap: 8px; }
        .suggest-pill {
            background: var(--card); border: 1px solid var(--border); padding: 8px 12px; border-radius: 12px; font-size: 0.75em; cursor: pointer; transition: 0.2s; display: flex; justify-content: space-between; align-items: center;
        }
        .suggest-pill:hover { border-color: var(--accent); background: #262c3d; }
        .suggest-items-text { font-weight: 700; color: #cbd5e1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; max-width: 70%; }
        .suggest-val-text { font-weight: 900; color: var(--win); }
        .inv-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.95); backdrop-filter: blur(12px); display: none; align-items: center; justify-content: center; z-index: 3000; }
        .inv-container { width: 95%; max-width: 1100px; background: #1a2333; border-radius: 28px; border: 1px solid var(--border); display: flex; flex-direction: column; max-height: 85vh; overflow: hidden; }
        .inv-header { padding: 25px; border-bottom: 1.5px solid var(--border); display: flex; justify-content: space-between; align-items: center; background: #111827; }
        .inv-body { display: flex; flex: 1; overflow: hidden; }
        .inv-list { flex: 1.5; padding: 25px; overflow-y: auto; border-right: 1.5px solid var(--border); }
        .inv-stats { flex: 1.2; padding: 30px; background: #0f172a; overflow-y: auto; }
        .stat-card { background: var(--panel); padding: 20px; border-radius: 18px; border: 1px solid var(--border); margin-bottom: 20px; }
        .stat-label { font-size: 0.85em; color: var(--subtext); text-transform: uppercase; letter-spacing: 1px; font-weight: 700; }
        .stat-value { font-size: 2em; font-weight: 950; color: white; margin-top: 5px; }
        .milestone-container { background: #161e2e; padding: 15px; border-radius: 15px; border: 1px solid var(--border); margin-top: 15px; }
        .milestone-row { display: flex; align-items: center; gap: 10px; margin-bottom: 8px; opacity: 0.4; transition: 0.3s; }
        .milestone-row.active { opacity: 1; color: var(--frost); font-weight: 800; }
        .milestone-check { width: 18px; height: 18px; border-radius: 50%; border: 2px solid var(--border); display: flex; align-items: center; justify-content: center; font-size: 10px; }
        .milestone-row.active .milestone-check { border-color: var(--win); background: var(--win); color: white; }
        .ai-box { background: rgba(99, 102, 241, 0.05); border: 1.5px solid var(--accent); border-radius: 20px; padding: 20px; margin-top: 10px; }
        .ai-title { display: flex; align-items: center; justify-content: space-between; color: var(--accent); font-weight: 900; font-size: 1.1em; margin-bottom: 15px; }
        .ai-summary { background: rgba(255,255,255,0.05); padding: 12px; border-radius: 10px; margin-bottom: 15px; border: 1px dashed var(--accent); font-size: 0.9em; line-height: 1.4; color: white; }
        .ai-suggestion { background: #161e2e; padding: 15px; border-radius: 12px; border-left: 4px solid var(--accent); margin-bottom: 12px; font-size: 0.95em; line-height: 1.4; }
        .ai-item-tag { display: inline-block; background: var(--accent); color: white; padding: 2px 8px; border-radius: 6px; font-weight: 800; font-size: 0.85em; margin: 2px; }
        
        .ai-stats-row { display: flex; gap: 10px; margin-top: 10px; padding-top: 10px; border-top: 1px solid #334155; }
        .ai-stat-pill { font-size: 0.75em; font-weight: 900; padding: 3px 8px; border-radius: 5px; }
        .pill-win { background: rgba(16, 185, 129, 0.15); color: var(--win); }
        .pill-dem { background: rgba(251, 191, 36, 0.15); color: var(--demand-color); }
        .ai-refresh-btn { background: var(--accent); color: white; border: none; padding: 5px 12px; border-radius: 8px; font-size: 0.7em; font-weight: 900; cursor: pointer; transition: 0.2s; }
        .ai-refresh-btn:hover { opacity: 0.8; transform: rotate(15deg); }
        .ai-toggle-group { display: flex; background: #0f172a; padding: 4px; border-radius: 10px; margin-bottom: 15px; gap: 4px; }
        .ai-tog { flex: 1; text-align: center; font-size: 0.7em; font-weight: 900; padding: 8px; border-radius: 7px; cursor: pointer; color: var(--subtext); transition: 0.2s; }
        .ai-tog.active { background: var(--accent); color: white; }
        .search-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.95); backdrop-filter: blur(12px); display: flex; align-items: center; justify-content: center; z-index: 4000; opacity: 0; pointer-events: none; transition: opacity 0.3s; }
        .search-overlay.open { opacity: 1; pointer-events: auto; }
        .search-container { width: 95%; max-width: 900px; background: #1a2333; border-radius: 28px; border: 1px solid var(--border); display: flex; flex-direction: column; max-height: 85vh; box-shadow: 0 25px 60px rgba(0,0,0,0.6); overflow: hidden; transform: scale(0.9); transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1); }
        .search-overlay.open .search-container { transform: scale(1); }
        .search-header { padding: 20px 25px; display: flex; gap: 12px; align-items: center; background: #111827; border-bottom: 1px solid var(--border); flex-wrap: wrap; }
        .search-input-wrapper { flex: 2; position: relative; display: flex; align-items: center; min-width: 200px; }
        #mainSearch { width: 100%; padding: 14px 15px 14px 45px; background: #262c3d; border: 1px solid #334155; border-radius: 35px; color: white; font-size: 1.1em; outline: none; }
        #sortSelect, #rarityFilter { flex: 1; padding: 14px 15px; background: #262c3d; border: 1px solid #334155; border-radius: 35px; color: #94a3b8; font-size: 0.95em; font-weight: 600; outline: none; cursor: pointer; min-width: 150px; }
        #sortSelect:hover, #rarityFilter:hover { border-color: var(--accent); color: white; }
        .search-icon-fixed { position: absolute; left: 18px; font-size: 1.2em; }
        .close-modal-btn { width: 45px; height: 45px; background: #262c3d; border-radius: 50%; display: flex; align-items: center; justify-content: center; cursor: pointer; color: #94a3b8; font-size: 1.4em; }
        .close-modal-btn:hover { background: #ef4444; color: white; }
        .results-grid { display: grid; grid-template-columns: repeat(auto-fill, minmax(140px, 1fr)); gap: 12px; padding: 25px; overflow-y: auto; background: #161e2e; scroll-behavior: smooth; }
        .search-item-card { background: #262c3d; border-radius: 18px; padding: 15px 10px; display: flex; flex-direction: column; align-items: center; cursor: pointer; transition: all 0.2s; border: 1.5px solid transparent; }
        .search-item-card:hover { background: #334155; transform: translateY(-4px); border-color: var(--accent); }
        .search-item-card.added { border-color: var(--win) !important; background: rgba(16, 185, 129, 0.1); }
        .search-item-name { font-size: 0.75em; font-weight: 800; color: #94a3b8; text-align: center; margin-bottom: 10px; min-height: 2.5em; overflow: visible; word-wrap: break-word; max-width: 100%; }
        .search-item-img { width: 85px; height: 85px; object-fit: contain; margin-bottom: 10px; }
        .search-item-val { font-weight: 900; font-size: 1.2em; color: white; }
        .search-item-demand { font-size: 0.9em; font-weight: 800; color: var(--demand-color); margin-top: 2px; text-shadow: 0 0 5px rgba(251, 191, 36, 0.3); }
        .results-grid::-webkit-scrollbar { width: 10px; }
        .results-grid::-webkit-scrollbar-thumb { background: #334155; border-radius: 10px; border: 2px solid #161e2e; }
        .similar-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.9); backdrop-filter: blur(8px); display: none; align-items: center; justify-content: center; z-index: 5000; }
        .similar-container { width: 90%; max-width: 600px; background: #1a2333; border-radius: 20px; border: 1px solid var(--border); padding: 20px; max-height: 70vh; overflow-y: auto; display: flex; flex-direction: column; }
        .similar-item { display: flex; align-items: center; gap: 15px; background: var(--card); padding: 12px; border-radius: 12px; margin-bottom: 10px; cursor: pointer; border: 1.5px solid transparent; transition: 0.2s; }
        .similar-item:hover { border-color: var(--accent); background: #334155; }
        .similar-item.selected { border-color: var(--win); background: rgba(16, 185, 129, 0.05); }
        
        .ai-count-control { margin-bottom: 15px; display: flex; flex-direction: column; gap: 5px; }
        .ai-fullscreen-btn { background: transparent; color: var(--accent); border: 1.5px solid var(--accent); padding: 4px 9px; border-radius: 7px; font-size: 0.7em; font-weight: 900; cursor: pointer; transition: 0.2s; margin-left: 6px; }
        .ai-fullscreen-btn:hover { background: var(--accent); color: white; }
        #aiFullscreenOverlay { display:none; position:fixed; inset:0; z-index:9000; background:rgba(0,0,0,0.85); backdrop-filter:blur(6px); padding:20px; box-sizing:border-box; flex-direction:column; }
        #aiFullscreenOverlay.open { display:flex; }
        #aiFullscreenInner { background:var(--card); border:1.5px solid var(--accent); border-radius:20px; padding:22px; flex:1; display:flex; flex-direction:column; overflow:hidden; max-width:860px; width:100%; margin:0 auto; }
        #aiFullscreenBody { flex:1; overflow-y:auto; margin-top:12px; }
        .ai-count-control label { font-size: 0.75em; color: var(--subtext); font-weight: 700; }
        .ai-count-control input { cursor: pointer; accent-color: var(--accent); }
        .history-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.95); backdrop-filter: blur(12px); display: none; align-items: center; justify-content: center; z-index: 4500; }
        .history-container { width: 95%; max-width: 600px; background: #1a2333; border-radius: 20px; border: 1px solid var(--border); max-height: 80vh; display: flex; flex-direction: column; }
        .history-header { padding: 20px; border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; }
        .history-list { padding: 20px; overflow-y: auto; }
        .history-item { background: var(--panel); border: 1px solid var(--border); padding: 15px; border-radius: 12px; margin-bottom: 10px; cursor: pointer; transition: 0.2s; }
        .history-item:hover { background: var(--card); border-color: var(--accent); }
        .history-time { font-size: 0.7em; color: var(--subtext); margin-bottom: 5px; }
        .history-details { display: flex; justify-content: space-between; align-items: center; font-weight: 800; font-size: 0.9em; }
        .dream-progress-bg { width: 100%; height: 10px; background: #0f172a; border-radius: 5px; overflow: hidden; margin: 10px 0; }
        .dream-progress-fill { height: 100%; background: var(--accent); width: 0%; transition: width 0.5s ease; }
        .dream-active-badge { background: var(--accent); color: white; padding: 5px 10px; border-radius: 8px; font-size: 0.8em; font-weight: 800; display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px; }
        .analytics-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2, 6, 23, 0.95); backdrop-filter: blur(12px); display: none; align-items: center; justify-content: center; z-index: 4600; }
        .analytics-container { width: 95%; max-width: 700px; background: #1a2333; border-radius: 28px; border: 1px solid var(--border); max-height: 85vh; display: flex; flex-direction: column; overflow: hidden; }
        .analytics-body { padding: 30px; overflow-y: auto; }
        .analytics-section { margin-bottom: 25px; }
        .analytics-section h4 { color: var(--accent); margin-bottom: 15px; font-weight: 900; text-transform: uppercase; letter-spacing: 1px; font-size: 0.9em; }
        .bar-row { display: flex; align-items: center; margin-bottom: 12px; }
        .bar-label { width: 100px; font-size: 0.8em; font-weight: 700; color: #cbd5e1; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
        .bar-track { flex: 1; height: 10px; background: #0f172a; border-radius: 5px; margin: 0 15px; overflow: hidden; }
        .bar-fill { height: 100%; border-radius: 5px; transition: width 0.5s ease; }
        .bar-stat { width: 60px; text-align: right; font-size: 0.8em; font-weight: 800; color: white; }
        .qty-modal-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.6); display: none; align-items: center; justify-content: center; z-index: 6000; }
        .qty-modal { background: #1a2333; border: 1px solid var(--border); padding: 25px; border-radius: 20px; width: 300px; text-align: center; }
        .qty-modal h3 { color: white; margin-bottom: 20px; font-size: 1.1em; }
        .qty-input { background: #0f172a; border: 1px solid var(--border); color: white; font-size: 1.5em; padding: 10px; width: 100%; border-radius: 10px; text-align: center; margin-bottom: 20px; outline: none; }
        .qty-input:focus { border-color: var(--accent); }
        .qty-actions { display: flex; gap: 10px; justify-content: center; }
    
        @keyframes pulse {
            0%, 100% { opacity: 1; transform: scale(1); }
            50% { opacity: 0.6; transform: scale(1.2); }
        }




        /* ===== HOME SCREEN / TAB SYSTEM ===== */
        .home-screen { width: 100%; max-width: 1150px; display: flex; flex-direction: column; align-items: center; }
        .tab-bar {
            display: flex; gap: 10px; margin-bottom: 28px;
            background: #111827; border-radius: 50px; padding: 6px;
            border: 1.5px solid var(--border);
        }
        .tab-btn {
            display: flex; align-items: center; gap: 8px;
            padding: 10px 28px; border-radius: 44px; border: none;
            font-weight: 900; font-size: 0.9em; cursor: pointer;
            transition: all 0.2s; color: var(--subtext); background: transparent;
            font-family: inherit;
        }
        .tab-btn.active { background: white; color: #111; box-shadow: 0 2px 12px rgba(0,0,0,0.3); }
        .tab-btn:not(.active):hover { color: white; background: rgba(255,255,255,0.07); }
        .tab-content { display: none; width: 100%; }
        .tab-content.active { display: block; }

        /* ===== VALUE LIST / DEMAND LIST ===== */
        .vlist-container {
            width: 100%; background: var(--panel); border-radius: 20px;
            border: 1.5px solid var(--border); overflow: hidden;
        }
        .vlist-header {
            padding: 16px 22px; background: #111827; border-bottom: 1.5px solid var(--border);
            display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;
        }

        .vlist-type-group { display:flex; gap:3px; background:#0f172a; border-radius:20px; padding:3px; border:1px solid var(--border); }
        .vlist-type-btn { padding:4px 12px; border-radius:16px; border:none; background:transparent; color:var(--subtext); font-weight:800; font-size:0.72em; cursor:pointer; transition:0.15s; font-family:inherit; white-space:nowrap; }
        .vlist-type-btn.active { background:var(--accent); color:white; }
        .vlist-type-btn:not(.active):hover { color:white; background:rgba(255,255,255,0.07); }
        .vlist-search {
            background: #1e293b; border: 1.5px solid var(--border); color: white;
            padding: 8px 14px; border-radius: 20px; font-size: 0.82em; font-weight: 700;
            outline: none; width: 220px; font-family: inherit;
        }
        .vlist-search::placeholder { color: var(--subtext); }
        .vlist-body { padding: 16px; }
        .vlist-tier-row {
            display: flex; align-items: flex-start; gap: 12px;
            margin-bottom: 10px; padding-bottom: 10px;
            border-bottom: 1px solid rgba(255,255,255,0.05);
        }
        .vlist-tier-label {
            min-width: 68px; font-size: 0.72em; font-weight: 900;
            color: var(--accent); padding-top: 6px; text-align: right; flex-shrink: 0;
        }
        .vlist-pets {
            display: flex; flex-wrap: wrap; gap: 5px; flex: 1;
        }
        .vlist-pet {
            width: 46px; height: 46px; border-radius: 10px;
            background: #1e293b; border: 1.5px solid var(--border);
            display: flex; align-items: center; justify-content: center;
            cursor: pointer; transition: 0.15s; position: relative; flex-shrink: 0;
        }
        .vlist-pet:hover { border-color: var(--accent); background: #273549; transform: scale(1.12); z-index: 10; }
        .vlist-pet img { width: 36px; height: 36px; object-fit: contain; }
        .vlist-pet-tooltip {
            position: absolute; bottom: calc(100% + 6px); left: 50%; transform: translateX(-50%);
            background: #0f172a; border: 1.5px solid var(--accent); color: white;
            font-size: 0.65em; font-weight: 900; padding: 4px 8px; border-radius: 8px;
            white-space: nowrap; pointer-events: none; opacity: 0; transition: opacity 0.1s;
            z-index: 100;
        }
        .vlist-pet:hover .vlist-pet-tooltip { opacity: 1; }
        .vlist-tier-row:last-child { border-bottom: none; margin-bottom: 0; }
        .demand-dot {
            width: 10px; height: 10px; border-radius: 50%; display: inline-block;
            margin-right: 4px; flex-shrink: 0;
        }

        /* ===== SETTINGS STYLES ===== */
        .settings-overlay { position:fixed;top:0;left:0;width:100%;height:100%;background:rgba(2,6,23,0.96);backdrop-filter:blur(14px);display:none;align-items:center;justify-content:center;z-index:5500; }
        .settings-container { width:94%;max-width:560px;background:#1a2333;border-radius:24px;border:1.5px solid var(--border);max-height:88vh;display:flex;flex-direction:column;overflow:hidden;box-shadow:0 30px 80px rgba(0,0,0,0.8); }
        .settings-header { padding:16px 22px;background:#111827;border-bottom:1.5px solid var(--border);display:flex;justify-content:space-between;align-items:center;flex-shrink:0; }
        .settings-body { padding:20px;overflow-y:auto;flex:1; }
        .settings-section { background:#0f172a;border-radius:14px;padding:16px;margin-bottom:16px;border:1px solid var(--border); }
        .settings-section-title { font-size:0.78em;font-weight:900;color:var(--accent);text-transform:uppercase;letter-spacing:1px;margin-bottom:4px; }
        .keybind-row { background:#1e293b;border-radius:10px;padding:10px 12px;display:flex;gap:8px;align-items:center;border:1px solid var(--border); }
        .keybind-key { background:var(--accent);color:white;font-weight:900;font-size:0.85em;padding:4px 10px;border-radius:8px;min-width:36px;text-align:center;cursor:pointer;flex-shrink:0; }
        .keybind-key:hover { opacity:0.8; }
        .keybind-select { background:#0f172a;border:1px solid var(--border);color:#cbd5e1;padding:5px 8px;border-radius:8px;font-size:0.75em;font-weight:700;flex:1;outline:none;cursor:pointer; }
        .keybind-remove { background:#ef4444;color:white;border:none;border-radius:8px;padding:4px 9px;cursor:pointer;font-size:0.8em;font-weight:900;flex-shrink:0; }
        .keybind-remove:hover { background:#dc2626; }
        .keybind-source-toggle { display:flex;gap:4px;flex-shrink:0; }
        .ks-tog { font-size:0.7em;font-weight:900;padding:4px 8px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--subtext);cursor:pointer; }
        .ks-tog.active { background:var(--accent);color:white;border-color:var(--accent); }

        /* ===== TRADE ADVISOR STYLES ===== */
        .advisor-overlay { position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(2,6,23,0.96); backdrop-filter: blur(14px); display: none; align-items: center; justify-content: center; z-index: 5200; }
        .advisor-container { width: 97%; max-width: 1050px; background: #1a2333; border-radius: 28px; border: 1.5px solid var(--border); max-height: 90vh; display: flex; flex-direction: column; overflow: hidden; box-shadow: 0 30px 80px rgba(0,0,0,0.8); }
        .advisor-header { padding: 18px 25px; background: #111827; border-bottom: 1.5px solid var(--border); display: flex; justify-content: space-between; align-items: center; flex-shrink: 0; }
        .advisor-body { display: flex; flex: 1; overflow: hidden; min-height: 0; }
        .advisor-left { width: 340px; flex-shrink: 0; padding: 20px; border-right: 1.5px solid var(--border); overflow-y: auto; background: #131c2b; }
        .advisor-right { flex: 1; display: flex; flex-direction: column; overflow: hidden; }
        .advisor-filters { padding: 12px 18px; background: #0f172a; border-bottom: 1px solid var(--border); display: flex; gap: 8px; flex-wrap: wrap; align-items: center; flex-shrink: 0; }
        .advisor-filter-select { background: #1e293b; border: 1px solid var(--border); color: #94a3b8; padding: 6px 10px; border-radius: 20px; font-size: 0.75em; font-weight: 700; outline: none; cursor: pointer; }
        .advisor-filter-select:hover { border-color: var(--accent); color: white; }
        .advisor-results { flex: 1; overflow-y: auto; padding: 15px; display: flex; flex-direction: column; gap: 10px; }
        .advisor-insight-bar { padding: 12px 18px; background: rgba(99,102,241,0.07); border-top: 1px solid var(--border); font-size: 0.78em; color: #94a3b8; line-height: 1.5; flex-shrink: 0; }
        .advisor-offer-slot { display: grid; grid-template-columns: repeat(3, 1fr); gap: 8px; margin-bottom: 15px; }
        .advisor-pet-chip { background: var(--card); border: 1.5px solid var(--border); border-radius: 12px; padding: 8px 6px; display: flex; flex-direction: column; align-items: center; position: relative; font-size: 0.7em; cursor: pointer; transition: 0.2s; }
        .advisor-pet-chip:hover { border-color: #ef4444; }
        .advisor-pet-chip img { width: 44px; height: 44px; object-fit: contain; margin-bottom: 3px; }
        .advisor-pet-chip .chip-name { text-align: center; color: #cbd5e1; font-weight: 800; font-size: 0.9em; line-height: 1.2; }
        .advisor-pet-chip .chip-val { color: var(--frost); font-weight: 900; margin-top: 2px; }
        .advisor-pet-chip .chip-remove { position: absolute; top: -5px; right: -5px; width: 18px; height: 18px; background: #ef4444; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 10px; color: white; }
        .advisor-add-slot { background: transparent; border: 2px dashed var(--border); border-radius: 12px; height: 80px; display: flex; align-items: center; justify-content: center; color: var(--border); font-size: 1.5em; cursor: pointer; transition: 0.2s; }
        .advisor-add-slot:hover { border-color: var(--accent); color: var(--accent); }
        .advisor-offer-stats { background: #0f172a; border-radius: 12px; padding: 12px; margin-bottom: 15px; font-size: 0.8em; }
        .advisor-stat-row { display: flex; justify-content: space-between; margin-bottom: 4px; }
        .advisor-stat-label { color: var(--subtext); }
        .advisor-stat-val { font-weight: 900; color: white; }
        .target-card { background: var(--card); border: 1.5px solid var(--border); border-radius: 16px; padding: 14px; display: flex; gap: 12px; align-items: flex-start; transition: 0.2s; cursor: default; }
        .target-card:hover { border-color: var(--accent); background: #262c3d; }
        .target-card img { width: 58px; height: 58px; object-fit: contain; flex-shrink: 0; border-radius: 10px; background: #0f172a; }
        .target-card-body { flex: 1; min-width: 0; }
        .target-name { font-weight: 900; font-size: 0.95em; color: white; margin-bottom: 4px; }
        .target-badges { display: flex; gap: 5px; flex-wrap: wrap; margin-bottom: 6px; }
        .target-badge { font-size: 0.65em; font-weight: 900; padding: 2px 7px; border-radius: 8px; }
        .badge-preppy { background: rgba(236,72,153,0.2); color: #f9a8d4; }
        .badge-hightier { background: rgba(168,85,247,0.2); color: #d8b4fe; }
        .badge-exotic { background: rgba(6,182,212,0.2); color: #67e8f9; }
        .badge-randoms { background: rgba(100,116,139,0.2); color: #94a3b8; }
        .badge-rising { background: rgba(16,185,129,0.2); color: #6ee7b7; }
        .badge-falling { background: rgba(239,68,68,0.2); color: #fca5a5; }
        .badge-ugly { background: rgba(239,68,68,0.15); color: #f87171; }
        .badge-manip { background: rgba(245,158,11,0.2); color: #fcd34d; }
        .target-reason { font-size: 0.75em; color: #94a3b8; line-height: 1.4; margin-bottom: 6px; }
        .target-meta { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; }
        .tqs-badge { font-size: 0.75em; font-weight: 900; padding: 3px 9px; border-radius: 10px; }
        .tqs-high { background: rgba(16,185,129,0.2); color: #34d399; }
        .tqs-mid  { background: rgba(251,191,36,0.2);  color: #fbbf24; }
        .tqs-low  { background: rgba(239,68,68,0.2);   color: #f87171; }
        .target-val-gap { font-size: 0.72em; font-weight: 800; color: var(--subtext); }
        .target-demand-pill { font-size: 0.72em; font-weight: 800; padding: 2px 7px; border-radius: 8px; background: rgba(251,191,36,0.1); color: var(--demand-color); }
        .advisor-section-title { font-size: 0.7em; font-weight: 900; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; margin: 8px 0 10px; }
        .advisor-inv-grid { display: grid; grid-template-columns: repeat(3, 1fr); gap: 7px; margin-top: 8px; }
        .advisor-inv-chip { background: #0f172a; border: 1.5px solid var(--border); border-radius: 10px; padding: 7px 5px; display: flex; flex-direction: column; align-items: center; cursor: pointer; transition: 0.2s; font-size: 0.68em; position: relative; }
        .advisor-inv-chip:hover { border-color: var(--win); background: rgba(16,185,129,0.06); }
        .advisor-inv-chip img { width: 38px; height: 38px; object-fit: contain; margin-bottom: 3px; }
        .advisor-inv-chip .inv-chip-name { text-align: center; color: #94a3b8; font-weight: 800; line-height: 1.2; }
        .advisor-inv-chip .inv-chip-val { color: var(--frost); font-weight: 900; margin-top: 1px; }
        .advisor-empty { text-align: center; color: var(--subtext); padding: 40px 20px; font-size: 0.9em; }
        /* Analytics pie container */
        .analytics-pie-row { display: flex; gap: 20px; flex-wrap: wrap; justify-content: center; margin-bottom: 20px; }
        .analytics-pie-card { background: var(--panel); border-radius: 18px; border: 1px solid var(--border); padding: 20px; flex: 1; min-width: 200px; max-width: 280px; text-align: center; }
        .analytics-pie-card h4 { color: var(--accent); font-size: 0.8em; text-transform: uppercase; letter-spacing: 1px; margin-bottom: 15px; font-weight: 900; }
        .analytics-pie-legend { margin-top: 12px; text-align: left; }
        .legend-row { display: flex; align-items: center; gap: 7px; margin-bottom: 5px; font-size: 0.72em; color: #cbd5e1; font-weight: 700; }
        .legend-dot { width: 10px; height: 10px; border-radius: 50%; flex-shrink: 0; }

        /* ===== NEW FEATURE STYLES ===== */
        .verdict-extras {
            position: fixed;
            left: 18px;
            bottom: 30px;
            width: 220px;
            display: flex;
            flex-direction: column;
            gap: 7px;
            z-index: 999;
            pointer-events: none;
        }
        .verdict-extras > * { pointer-events: auto; }
        @media screen and (max-width: 900px) {
            .verdict-extras { display: none; }
        }
        .trade-type-tag { font-size: 0.75em; font-weight: 900; padding: 4px 14px; border-radius: 20px; display: inline-block; letter-spacing: 0.5px; }
        .tag-downgrade { background: rgba(239,68,68,0.18); color: #fca5a5; border: 1px solid rgba(239,68,68,0.4); }
        .tag-penalty { background: rgba(245,158,11,0.18); color: #fcd34d; border: 1.5px solid rgba(245,158,11,0.5); }
        .tag-played { background: rgba(239,68,68,0.22); color: #f87171; border: 2px solid #ef4444; font-size: 0.8em; font-weight: 900; padding: 5px 14px; border-radius: 20px; animation: pulse 2s infinite; }
        .speed-row { display: flex; gap: 8px; justify-content: center; flex-wrap: wrap; font-size: 0.75em; font-weight: 900; }
        .speed-pill { padding: 3px 10px; border-radius: 12px; }
        .speed-fast { background: rgba(16,185,129,0.15); color: #34d399; }
        .speed-mod  { background: rgba(251,191,36,0.15);  color: #fbbf24; }
        .speed-slow { background: rgba(239,68,68,0.15);   color: #f87171; }
        .flip-row { font-size: 0.78em; font-weight: 800; color: var(--subtext); }
        .flip-high { color: #34d399; }
        .flip-med  { color: #fbbf24; }
        .flip-low  { color: #f87171; }
        /* Trending search section */
        .trending-section { padding: 12px 25px 0; border-bottom: 1px solid var(--border); background: rgba(99,102,241,0.04); }
        .trending-title { font-size: 0.7em; font-weight: 900; color: var(--accent); text-transform: uppercase; letter-spacing: 1px; margin-bottom: 8px; display: flex; align-items: center; gap: 6px; }
        .trending-pills { display: flex; gap: 7px; flex-wrap: wrap; margin-bottom: 10px; }
        .trending-pill { background: rgba(99,102,241,0.12); border: 1px solid rgba(99,102,241,0.35); border-radius: 20px; padding: 5px 11px; font-size: 0.7em; font-weight: 800; cursor: pointer; color: #c7d2fe; transition: 0.2s; display: flex; align-items: center; gap: 4px; }
        .trending-pill:hover { background: rgba(99,102,241,0.28); border-color: var(--accent); }

        /* ========================================
           MOBILE RESPONSIVE STYLES
           ======================================== */
        
        /* Mobile Devices (phones) */
        @media screen and (max-width: 768px) {
    body {
        padding: 10px;
    }

    .nav-bar {
        flex-wrap: wrap;
        gap: 5px;
    }

    .nav-btn {
        padding: 8px 12px;
        font-size: 0.85em;
    }

    .container {
        margin-top: 20px;
        margin-bottom: 200px;
        gap: 15px;
        flex-direction: row;
    }
        .trade-panel {
    min-width: 340px;
    flex: 1;
}

        .grid {
            grid-template-columns: repeat(auto-fill, minmax(90px, 1fr));
            gap: 10px;
            padding: 15px;
        }

        .card {
            padding: 8px 6px;
        }

        .card-img-container {
            width: 50px;
            height: 50px;
        }

        .card-name {
            font-size: 0.65em;
        }

        .card-val {
            font-size: 0.85em;
        }

        .verdict-box {
            bottom: 10px;
            padding: 15px;
            max-width: 95%;
        }

        .v-text {
            font-size: 2em;
        }

        .switches {
            flex-wrap: wrap;
            gap: 5px;
        }

        .sw-btn {
            padding: 6px 16px;
            font-size: 0.85em;
        }

        .save-trade-btn {
            padding: 6px 12px;
            font-size: 0.75em;
            margin-left: 0;
            margin-top: 5px;
        }

        /* Search Modal Mobile */
        .search-container {
            max-width: 100%;
            max-height: 95vh;
        }

        .search-header {
            flex-direction: column;
            gap: 8px;
        }

        .search-input-wrapper {
            width: 100%;
            min-width: 100%;
        }

        #sortSelect, #rarityFilter {
            width: 100%;
            min-width: 100%;
        }

        .results-grid {
            grid-template-columns: repeat(auto-fill, minmax(100px, 1fr));
            gap: 10px;
            padding: 15px;
        }

        .search-item-card {
            padding: 10px 8px;
        }

        .search-item-img {
            width: 60px;
            height: 60px;
        }

        /* Inventory Mobile */
        .inv-container {
            max-width: 100%;
            max-height: 95vh;
        }

        .inv-header {
            flex-direction: column;
            gap: 10px;
            padding: 15px;
        }

        .inv-header > div {
            flex-direction: column;
            width: 100%;
            gap: 5px;
        }

        .inv-body {
            flex-direction: column;
        }

        .inv-list {
            border-right: none;
            border-bottom: 1.5px solid var(--border);
        }

        /* Info/Graph Modals Mobile */
        .graph-container,
        .info-container,
        .analytics-container,
        .history-container {
            max-width: 100%;
            max-height: 90vh;
        }

        .graph-body {
            height: 300px;
            padding: 15px;
        }

        .info-body {
            padding: 20px;
        }

        /* Quantity Modal Mobile */
        .qty-modal {
            width: 90%;
            padding: 20px;
        }

        /* AI Box Mobile */
        .ai-suggestion {
            font-size: 0.85em;
            padding: 12px;
        }

        .ai-toggle-group {
            flex-direction: column;
        }

        .ai-tog {
            padding: 10px;
            font-size: 0.8em;
        }
    }

    /* Tablet/Medium Screen Adjustments */
    @media screen and (min-width: 769px) and (max-width: 1024px) {
        .container {
            max-width: 100%;
        }

        .trade-panel {
            min-width: 45%;
        }

        .grid {
            grid-template-columns: repeat(auto-fill, minmax(95px, 1fr));
        }
    }

    /* Prevent zoom on input focus (iOS Safari) */
    @media screen and (max-width: 768px) {
        input, select, textarea {
            font-size: 16px !important;
        }
    }

    /* Touch-friendly interactions */
    @media (hover: none) and (pointer: coarse) {
        .card:hover {
            transform: none;
        }

        .card:active {
            transform: scale(0.98);
        }

        .nav-btn:hover {
            background: var(--panel);
        }

        .nav-btn:active {
            background: var(--card);
        }

        .plus:hover {
            border-color: var(--border);
            color: var(--border);
        }

        .plus:active {
            border-color: var(--accent);
            color: var(--accent);
        }
    }
</style>
</head>
<body>

    <div class="loading-screen" id="loadingScreen">
        <div class="loading-spinner"></div>
        <div class="loading-text">Loading pet data from Google Sheets...</div>
    </div>

    <!-- Feature: History Graph Overlay -->
    <div id="graphOverlay">
        <div class="graph-container">
            <div class="graph-header">
                <h2 id="graphTitle" style="color: white; font-weight: 900;">PET HISTORY</h2>
                <button class="nav-btn" onclick="closeGraph()">Close</button>
            </div>
            <div class="graph-body">
                <canvas id="petChart"></canvas>
            </div>
            <div style="padding: 20px; background: #0f172a; border-top: 1px solid var(--border); color: #cbd5e1; line-height: 1.6;" id="trendAnalysis"></div>
        </div>
    </div>

    <!-- Feature: Information Overlay -->
    <div id="infoOverlay">
        <div class="info-container">
            <div class="info-header">
                <h3 style="color: white; font-weight: 950;">‚ÑπÔ∏è CALCULATOR GUIDE</h3>
                <button class="nav-btn" onclick="closeInfo()">Close</button>
            </div>
            <div class="info-body">
                <div class="info-section">
                    <h4>Mouse Keybinds</h4>
                    <div class="info-row"><span class="info-label">Right Click:</span><span class="info-val">Open Multi-Add (Quantity) Menu</span></div>
                    <div class="info-row"><span class="info-label">Shift + Right Click:</span><span class="info-val">View Demand & Value History Graph</span></div>
                    <div class="info-row"><span class="info-label">Double Click Image:</span><span class="info-val">Duplicate Pet Card</span></div>
                    <div class="info-row"><span class="info-label">Hover on Emojis:</span><span class="info-val">See exact amount of change in tooltip</span></div>
                </div>
                <div class="info-section">
                    <h4>Keyboard Keybinds</h4>
                    <div class="info-row"><span class="info-label">Ctrl + Z:</span><span class="info-val">Undo Last Change</span></div>
                        <div class="info-row"><span class="info-label">Ctrl + Y:</span><span class="info-val">Redo Last Change</span></div>
                </div>
                <div class="info-section">
                    <h4>Trend Emojis</h4>
                    <div class="info-row"><span class="info-label">üî• :</span><span class="info-val">Demand is increasing</span></div>
                    <div class="info-row"><span class="info-label">‚ùÑÔ∏è :</span><span class="info-val">Demand is decreasing</span></div>
                    <div class="info-row"><span class="info-label">üìà :</span><span class="info-val">Value is increasing</span></div>
                    <div class="info-row"><span class="info-label">üìâ :</span><span class="info-val">Value is decreasing</span></div>
                </div>
            </div>
        </div>
    </div>

    <!-- HOME SCREEN WRAPPER -->
    <div class="home-screen" id="homeScreen">

    <!-- TAB BAR -->
    <div class="tab-bar">
        <button class="tab-btn" id="tabBtnValue" onclick="switchTab('value')">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><rect x="3" y="3" width="7" height="7"/><rect x="14" y="3" width="7" height="7"/><rect x="14" y="14" width="7" height="7"/><rect x="3" y="14" width="7" height="7"/></svg>
            Value List
        </button>
        <button class="tab-btn" id="tabBtnDemand" onclick="switchTab('demand')">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><polyline points="23 6 13.5 15.5 8.5 10.5 1 18"/><polyline points="17 6 23 6 23 12"/></svg>
            Demand List
        </button>
        <button class="tab-btn active" id="tabBtnCalc" onclick="switchTab('calc')">
            <svg width="15" height="15" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.5"><rect x="2" y="2" width="20" height="20" rx="3"/><line x1="8" y1="6" x2="16" y2="6"/><line x1="8" y1="10" x2="16" y2="10"/><line x1="8" y1="14" x2="14" y2="14"/><line x1="8" y1="18" x2="12" y2="18"/></svg>
            Value Calculator
        </button>
    </div>

    <!-- VALUE LIST TAB -->
    <div class="tab-content" id="tabValue">
        <div class="vlist-container">
            <div class="vlist-header">
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
                    <span style="font-weight:900;color:white">üìä Value List</span>
                    <div class="vlist-type-group">
                        <button class="vlist-type-btn active" id="vTypeNormal" onclick="setVListType('value','normal')">Normal</button>
                        <button class="vlist-type-btn" id="vTypeNeon" onclick="setVListType('value','neon')">Neon</button>
                        <button class="vlist-type-btn" id="vTypeMega" onclick="setVListType('value','mega')">Mega Neon</button>
                    </div>
                </div>
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
                    <div style="display:flex;align-items:center;gap:7px;background:var(--panel);border:1.5px solid var(--accent);border-radius:8px;padding:4px 10px">
                        <span style="font-size:0.75em;color:var(--accent);font-weight:900;letter-spacing:0.03em">üîç Zoom</span>
                        <input type="range" id="valueZoom" min="32" max="90" value="46"
                            oninput="setListZoom('value',this.value)"
                            style="width:90px;accent-color:var(--accent);cursor:pointer">
                    </div>
                    <input class="vlist-search" id="valueListSearch" placeholder="üîç Search pets..." oninput="renderValueList()">
                </div>
            </div>
            <div class="vlist-body" id="valueListBody">
                <div style="text-align:center;color:var(--subtext);padding:40px">Loading...</div>
            </div>
        </div>
    </div>

    <!-- DEMAND LIST TAB -->
    <div class="tab-content" id="tabDemand">
        <div class="vlist-container">
            <div class="vlist-header">
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
                    <span style="font-weight:900;color:white">üî• Demand List</span>
                    <div class="vlist-type-group">
                        <button class="vlist-type-btn active" id="dTypeNormal" onclick="setVListType('demand','normal')">Normal</button>
                        <button class="vlist-type-btn" id="dTypeNeon" onclick="setVListType('demand','neon')">Neon</button>
                        <button class="vlist-type-btn" id="dTypeMega" onclick="setVListType('demand','mega')">Mega Neon</button>
                    </div>
                </div>
                <div style="display:flex;align-items:center;gap:10px;flex-wrap:wrap">
                    <div style="display:flex;align-items:center;gap:5px;background:var(--panel);border:1.5px solid #334155;border-radius:8px;padding:4px 8px">
                        <span style="font-size:0.72em;color:var(--subtext);font-weight:800;margin-right:2px">Step</span>
                        <button class="vlist-type-btn active" id="dInc01" onclick="setDemandIncrement(0.1)">0.1</button>
                        <button class="vlist-type-btn" id="dInc05" onclick="setDemandIncrement(0.5)">0.5</button>
                        <button class="vlist-type-btn" id="dInc1" onclick="setDemandIncrement(1)">1</button>
                    </div>
                    <div style="display:flex;align-items:center;gap:7px;background:var(--panel);border:1.5px solid var(--accent);border-radius:8px;padding:4px 10px">
                        <span style="font-size:0.75em;color:var(--accent);font-weight:900;letter-spacing:0.03em">üîç Zoom</span>
                        <input type="range" id="demandZoom" min="32" max="90" value="46"
                            oninput="setListZoom('demand',this.value)"
                            style="width:90px;accent-color:var(--accent);cursor:pointer">
                    </div>
                    <input class="vlist-search" id="demandListSearch" placeholder="üîç Search pets..." oninput="renderDemandList()">
                </div>
            </div>
            <div class="vlist-body" id="demandListBody">
                <div style="text-align:center;color:var(--subtext);padding:40px">Loading...</div>
            </div>
        </div>
    </div>

    <!-- CALCULATOR TAB -->
    <div class="tab-content active" id="tabCalc">

    <!-- original nav buttons inside calc tab -->
    <div class="nav-bar">
        <button class="nav-btn" onclick="openInfo()">‚ÑπÔ∏è Information</button>
        <button class="nav-btn" onclick="openHistory()">üìú History</button>
        <button class="nav-btn" onclick="openInventory()">üì¶ My Inventory</button>
        <button class="nav-btn" onclick="openSettings()">‚öôÔ∏è Settings</button>
    </div>

    <div class="analytics-overlay" id="analyticsOverlay">
        <div class="analytics-container">
            <div class="history-header">
                <h3 style="color: white; font-weight: 900;">INVENTORY PORTFOLIO</h3>
                <button class="nav-btn" style="padding: 5px 15px;" onclick="closeAnalytics()">Close</button>
            </div>
            <div class="analytics-body" id="analyticsBody"></div>
        </div>
    </div>

    <div class="qty-modal-overlay" id="qtyModal" onclick="closeQtyModal()">
        <div class="qty-modal" onclick="event.stopPropagation()">
            <h3 id="qtyTitle">How many?</h3>
            <input type="number" id="qtyInput" class="qty-input" min="1" max="18" value="1">
            <div class="qty-actions">
                <button class="nav-btn" onclick="confirmQty()">Add</button>
                <button class="nav-btn" style="background: #ef4444; border-color: #b91c1c;" onclick="closeQtyModal()">Cancel</button>
            </div>
        </div>
    </div>

    <div class="history-overlay" id="historyOverlay">
        <div class="history-container">
            <div class="history-header">
                <h3 style="color: white;">Trade History (Last 10)</h3>
                <button class="nav-btn" style="padding: 5px 15px;" onclick="closeHistory()">Close</button>
            </div>
            <div class="history-list" id="historyList">
                <div style="text-align: center; color: var(--subtext);">No history yet. Calculate trades to save them!</div>
            </div>
        </div>
    </div>

    <div class="similar-overlay" id="similarOverlay" onclick="closeSimilarPopup()">
        <div class="similar-container" onclick="event.stopPropagation()">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h3 style="font-weight: 900; color: var(--accent);">Target Selection</h3>
                <button class="nav-btn" style="padding: 5px 15px; font-size: 0.75em;" onclick="closeSimilarPopup()">Confirm</button>
            </div>
            <div id="similarList"></div>
        </div>
    </div>

    <div class="inv-overlay" id="invOverlay">
        <div class="inv-container">
            <div class="inv-header">
                <div style="display:flex; gap:10px; align-items:center;">
                    <h2 style="font-weight: 900;">INVENTORY</h2>
                    <button class="nav-btn" style="padding: 6px 12px; font-size: 0.7em;" onclick="exportInv()">Export Data</button>
                    <button class="nav-btn" style="padding: 6px 12px; font-size: 0.7em;" onclick="importInv()">Import Data</button>
                    <button class="nav-btn" style="padding: 6px 12px; font-size: 0.7em; background: var(--accent); border-color: var(--accent);" onclick="openAnalytics()">View Portfolio</button>
                    <button class="nav-btn" style="padding: 6px 12px; font-size: 0.7em; background: #059669; border-color: #047857;" onclick="openTradeAdvisor()">üéØ Trade Advisor</button>
                </div>
                <button class="nav-btn" onclick="closeInventory()">Close</button>
            </div>
            <div class="inv-body">
                <div class="inv-list">
                    <button class="nav-btn" style="width: 100%; margin-bottom: 20px;" onclick="openSearch('inv')">+ Add Item to Inventory</button>
                    <div class="grid" id="invGrid"></div>
                </div>
                <div class="inv-stats">
                    <div class="stat-card">
                        <div class="stat-label">Total Normal Value</div>
                        <div class="stat-value" id="invTotalValue">0.00</div>
                        <button class="nav-btn" style="width: 100%; margin-top: 15px; padding: 8px; font-size: 0.75em;" onclick="findSimilarToTotal()">Find Global Value Matches</button>
                    </div>
                    <div class="stat-card">
                        <div class="stat-label">Average Demand</div>
                        <div class="stat-value" id="invAvgDemand">0.0</div>
                    </div>

                    <div class="milestone-container">
                        <div style="font-size: 0.8em; font-weight: 900; color: var(--accent); margin-bottom: 10px;">TRADING MILESTONES</div>
                        <div class="milestone-row" id="mile-1"><div class="milestone-check">‚úì</div>Starter (1.0 Val)</div>
                        <div class="milestone-row" id="mile-2"><div class="milestone-check">‚úì</div>Apprentice (10.0 Val)</div>
                        <div class="milestone-row" id="mile-3"><div class="milestone-check">‚úì</div>Merchant (50.0 Val)</div>
                        <div class="milestone-row" id="mile-4"><div class="milestone-check">‚úì</div>Rich (100.0 Val)</div>
                        <div class="milestone-row" id="mile-5"><div class="milestone-check">‚úì</div>Master (155.0 Val)</div>
                    </div>
                    
                    <div class="ai-box">
                        <div class="ai-title">
                            ü§ñ AI Strategist
                            <div style="display:flex;gap:6px;align-items:center">
                                <button class="ai-fullscreen-btn" onclick="openAIFullscreen()" title="Fullscreen">‚õ∂ Expand</button>
                                <button class="ai-refresh-btn" onclick="renderInventory()">Refresh ‚Üª</button>
                            </div>
                        </div>
                        
                        <div class="ai-toggle-group">
                            <div class="ai-tog active" id="aiTogNormal" onclick="setAiStrategy('normal')">Normal Mode</div>
                            <div class="ai-tog" id="aiTogVelocity" onclick="setAiStrategy('velocity')">Velocity Mode</div>
                        </div>

                        <div id="dreamPetContainer" style="margin-bottom: 15px;">
                            <button class="nav-btn" style="width: 100%; font-size: 0.8em; padding: 8px;" onclick="openSearch('dream')">‚òÖ Set Dream Pet</button>
                        </div>

                        <div class="ai-count-control">
                            <label>Strategy Count: <span id="strategyCountVal">10</span></label>
                            <input type="range" id="strategyCountSlider" min="1" max="10" value="10" oninput="updateStrategyCount(this.value)">
                        </div>

                        <div id="aiSuggestions">
                            <div class="ai-suggestion">Add pets to your inventory to generate AI-driven trade offers.</div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>



    <!-- Settings Overlay -->
    <div class="settings-overlay" id="settingsOverlay" onclick="if(event.target===this)closeSettings()">
        <div class="settings-container">
            <div class="settings-header">
                <span style="font-weight:900;font-size:1.05em">‚öôÔ∏è SETTINGS</span>
                <button class="nav-btn" onclick="closeSettings()">Close</button>
            </div>
            <div class="settings-body">

                <!-- UI Scale -->
                <div class="settings-section">
                    <div class="settings-section-title">üîç UI Scale</div>
                    <div style="display:flex;align-items:center;gap:12px;margin-top:8px">
                        <input type="range" id="uiScaleSlider" min="80" max="130" value="100"
                            oninput="applyUIScale(this.value)"
                            style="flex:1;accent-color:var(--accent)">
                        <span id="uiScaleLabel" style="font-weight:900;color:var(--accent);min-width:40px">100%</span>
                        <button class="nav-btn" style="font-size:0.75em;padding:5px 10px" onclick="applyUIScale(100)">Reset</button>
                    </div>
                </div>

                <!-- Keybinds -->
                <div class="settings-section">
                    <div class="settings-section-title">‚å®Ô∏è Pet Keybinds</div>
                    <div style="font-size:0.75em;color:var(--subtext);margin:6px 0 12px">
                        Press a key ‚Üí assign a pet ‚Üí it gets added to <b>your side</b> of the trade when you press that key.<br>
                        <span style="color:#fbbf24">Ctrl+Z</span> = Undo &nbsp;|&nbsp; <span style="color:#fbbf24">Ctrl+Y</span> = Redo
                    </div>
                    <div id="keybindList" style="display:flex;flex-direction:column;gap:8px;margin-bottom:12px"></div>
                    <button class="nav-btn" style="width:100%;font-size:0.8em" onclick="addKeybind()">+ Add New Keybind</button>
                </div>

            </div>
        </div>
    </div>

    <!-- Key capture modal -->
    <div class="settings-overlay" id="keyCaptureOverlay" style="z-index:6000" onclick="cancelKeyCapture()">
        <div class="settings-container" style="max-width:380px" onclick="event.stopPropagation()">
            <div class="settings-header">
                <span style="font-weight:900">Press Any Key</span>
            </div>
            <div style="padding:30px;text-align:center">
                <div style="font-size:2em;font-weight:900;color:var(--accent);min-height:50px" id="keyCaptureDisplay">Waiting...</div>
                <div style="font-size:0.8em;color:var(--subtext);margin-top:8px">Press any key (not Ctrl/Alt/Shift)</div>
                <div style="display:flex;gap:10px;margin-top:20px;justify-content:center">
                    <button class="nav-btn" id="keyCaptureConfirm" onclick="confirmKeyCapture()" disabled>Use This Key</button>
                    <button class="nav-btn" style="background:#334155" onclick="cancelKeyCapture()">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Trade Advisor Overlay -->
    <div class="advisor-overlay" id="advisorOverlay" onclick="if(event.target===this)closeTradeAdvisor()">
        <div class="advisor-container">
            <div class="advisor-header">
                <div>
                    <span style="font-weight:900; font-size:1.1em; color:white;">üéØ TRADE ADVISOR</span>
                    <span style="font-size:0.75em; color:var(--subtext); margin-left:10px;">Build your offer ‚Üí see what you should be targeting</span>
                </div>
                <button class="nav-btn" onclick="closeTradeAdvisor()">Close</button>
            </div>
            <div class="advisor-body">
                <div class="advisor-left">
                    <div class="advisor-section-title">üì¶ Your Offer (from inventory)</div>
                    <div id="advisorOfferSlots" class="advisor-offer-slot"></div>
                    <div id="advisorOfferStats" class="advisor-offer-stats">
                        <div style="text-align:center;color:var(--subtext);font-size:0.85em;">Add pets to see offer stats</div>
                    </div>
                    <div class="advisor-section-title" style="margin-top:15px;">‚ûï Click to add from inventory</div>
                    <div id="advisorInvGrid" class="advisor-inv-grid"></div>
                </div>
                <div class="advisor-right">
                    <div class="advisor-filters">
                        <span style="font-size:0.72em;font-weight:900;color:var(--subtext);">FILTERS:</span>
                        <select class="advisor-filter-select" id="advisorDemandFilter" onchange="refreshAdvisorTargets()">
                            <option value="0">Any Demand</option>
                            <option value="4">Demand 4+</option>
                            <option value="6">Demand 6+</option>
                            <option value="7">Demand 7+ only</option>
                        </select>
                        <select class="advisor-filter-select" id="advisorCatFilter" onchange="refreshAdvisorTargets()">
                            <option value="all">All Categories</option>
                            <option value="high tier">High Tier</option>
                            <option value="preppy">Preppy</option>
                            <option value="exotic">Exotic</option>
                        </select>
                        <select class="advisor-filter-select" id="advisorWindowFilter" onchange="refreshAdvisorTargets()">
                            <option value="0.20">¬±20% Value</option>
                            <option value="0.30">¬±30% Value</option>
                            <option value="0.40">¬±40% Value</option>
                            <option value="0.60">¬±60% Value</option>
                        </select>
                        <select class="advisor-filter-select" id="advisorSortFilter" onchange="refreshAdvisorTargets()">
                            <option value="tqs">Sort: Quality Score</option>
                            <option value="demand">Sort: Demand</option>
                            <option value="value">Sort: Value Gain</option>
                        </select>
                    </div>
                    <div class="advisor-results" id="advisorResults">
                        <div class="advisor-empty">Add pets to your offer on the left to see smart recommendations.</div>
                    </div>
                    <div class="advisor-insight-bar" id="advisorInsightBar">
                        Add pets from your inventory to your offer, then see what you should be trading for.
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="search-overlay" id="searchOverlay" onclick="closeSearch()">
        <div class="search-container" onclick="event.stopPropagation()">
            <div class="search-header">
                <div class="search-input-wrapper">
                    <span class="search-icon-fixed">üîç</span>
                    <input type="text" id="mainSearch" placeholder="Search for a pet..." autocomplete="off">
                </div>
                
                <select id="rarityFilter" onchange="updateFilter()">
                    <option value="none">Rarity: None</option>
                    <option value="high tier">High Tier</option>
                    <option value="mid tier">Mid Tier</option>
                    <option value="classy">Classy</option>
                    <option value="randoms">Randoms</option>
                    <option value="default legs">Default Legs</option>
                    <option value="preppy">Preppy</option>
                    <option value="exotic">Exotic</option>
                    <option value="legendary">Legendary</option>
                    <option value="ultra-rare">Ultra-Rare</option>
                    <option value="rare">Rare</option>
                    <option value="uncommon">Uncommon</option>
                    <option value="common">Common</option>
                </select>

                <select id="sortSelect" onchange="updateFilter()">
                    <option value="default">Default</option>
                    <option value="valHigh">Value (High ‚Üí Low)</option>
                    <option value="valLow">Value (Low ‚Üí High)</option>
                    <option value="demHigh">Demand (High ‚Üí Low)</option>
                    <option value="demLow">Demand (Low ‚Üí High)</option>
                </select>
                <div class="close-modal-btn" onclick="closeSearch()">‚úï</div>
            </div>
            <div class="results-grid" id="searchResults"></div>
        </div>
    </div>

    <div class="container">
        <div class="trade-panel" id="panelA">
            <div class="p-header">
                <div>
                    <span class="p-title">You Give (<span id="cntA">0</span>)</span>
                    <span class="p-dem" id="demA">Avg Demand: 0.0</span>
                </div>
                <span class="p-total" id="totA">0.000</span>
            </div>
            <div class="grid" id="gridA"></div>
            <div class="inv-suggest-container" id="sideASuggestions" style="display: none;">
                <div class="inv-suggest-title">ü§ñ Smart Offer Suggestions</div>
                <div class="suggest-pill-row" id="suggestList"></div>
            </div>
        </div>

        <div class="trade-panel" id="panelB">
            <div class="p-header">
                <div>
                    <span class="p-title">They Give (<span id="cntB">0</span>)</span>
                    <span class="p-dem" id="demB">Avg Demand: 0.0</span>
                </div>
                <span class="p-total" id="totB">0.000</span>
            </div>
            <div class="grid" id="gridB"></div>
        </div>
    </div>

    <div class="verdict-box">
        <div class="gauge-wrapper">
            <div id="gaugeBar" class="gauge-bar"></div>
            <div id="gaugeNeedle" class="gauge-needle"></div>
        </div>
        
        <div id="verdict" class="v-text">--</div>
        <div id="vDiff" class="v-diff">Difference: 0.000 (0.0%)</div>
        <div id="vSub" class="v-sub">Add pets to calculate trade results</div>
        <div class="switches">
            <button class="sw-btn active" id="btnValue" onclick="setMode('value')">Value</button>
            <button class="save-trade-btn" onclick="logCurrentTrade()">Save to History</button>
        </div>
    </div>  <!-- end tabCalc -->
    </div>  <!-- end homeScreen -->

   <script>
        // CRITICAL DATA VARIABLES DEFINED AT TOP
        const MASTER_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRpYtDhy048sVlxFk5obx9I2uSBxu89gzCCpyttrzza85TsVAtL-JsX0id93Q7q7WcNXLVms4SgR8Jg/pub?gid=697881438&single=true&output=csv';
        const HISTORY_CSV_URL = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vRpYtDhy048sVlxFk5obx9I2uSBxu89gzCCpyttrzza85TsVAtL-JsX0id93Q7q7WcNXLVms4SgR8Jg/pub?gid=1671406739&single=true&output=csv';
        
        let ALL_PETS = [];
        let HISTORY_DATA = []; 
        let state = { mode: 'value', A: [], B: [], inv: [], target: 'A', aiMode: 'normal', strategyLimit: 10, aiTargetPets: [], dreamPet: null, keybinds: [], uiScale: 1.0 };
        // Pet names locked from AI suggestions (persisted separately)
        const lockedPets = new Set(JSON.parse(localStorage.getItem('lockedPets') || '[]'));
        function saveLockedPets() { try { localStorage.setItem('lockedPets', JSON.stringify([...lockedPets])); } catch(e) {} }
        function toggleLockPet(name) { if (lockedPets.has(name)) lockedPets.delete(name); else lockedPets.add(name); saveLockedPets(); renderInventory(); }
        let history = []; 
        let tradeLog = []; 
        let selectedPetForQty = null; 
        let searchState = { currentMatches: [], renderLimit: 50, sortMode: 'default', rarityFilter: 'none' };
        let petChart = null;
        // Essential Helper Functions
        function getRarityColor(rarity) {
            if (!rarity) return 'var(--rarity-common)';
            const r = rarity.toLowerCase();
            if (r.includes('legendary')) return 'var(--rarity-legendary)';
            if (r.includes('ultra')) return 'var(--rarity-ultra)';
            if (r.includes('rare')) return 'var(--rarity-rare)';
            if (r.includes('uncommon')) return 'var(--rarity-uncommon)';
            return 'var(--rarity-common)';
        }
        function getDemandColor(demand) {
            if (demand >= 7) return '#4caf50';
            if (demand >= 4) return '#ffeb3b';
            return '#f44336';
        }
        function getTrendIcons(p) {
    if (!p || (!p.vt && !p.dt)) return "";
    let html = "";
    try {
        let crashWarning = "";
        
        // DEBUG: Check if history data exists
        if (!Array.isArray(HISTORY_DATA) || HISTORY_DATA.length === 0) {
            console.log("‚ö†Ô∏è No history data loaded yet for", p.n);
        } else {
            try {
                // Case-insensitive name matching
                const petHistory = HISTORY_DATA.filter(row => 
                    row.name && p.n && 
                    row.name.toLowerCase().trim() === p.n.toLowerCase().trim()
                );
                console.log(`üìä ${p.n}: Found ${petHistory.length} history records`);
                
                if (petHistory.length >= 2) {
                    const currentData = petHistory[petHistory.length - 1];
                    const lookbackLimit = Math.min(10, petHistory.length);
                    const historicalData = petHistory.slice(-lookbackLimit);
                    
                    let maxDemand = Math.max(...historicalData.map(h => h.d));
                    let maxValue = Math.max(...historicalData.map(h => h.v));
                    
                    const demandDrop = maxDemand - currentData.d;
                    const valueDrop = maxValue - currentData.v;
                    
                    console.log(`${p.n} - Demand drop: ${demandDrop.toFixed(2)}, Value drop: ${valueDrop.toFixed(2)}`);
                    
                    let hasCrashed = false;
                    let crashType = "";
                    let crashAmount = 0;
                    
                    if (demandDrop > 0.3) {
                        hasCrashed = true;
                        crashType = "DEMAND";
                        crashAmount = demandDrop;
                    }
                    
                    if (valueDrop > 2.0) {
                        hasCrashed = true;
                        if (crashType) crashType += " & VALUE";
                        else crashType = "VALUE";
                        crashAmount = Math.max(crashAmount, valueDrop);
                    }
                    
                    if (hasCrashed) {
                        const isRecovering = petHistory.length >= 3 && 
                                           currentData.d > petHistory[petHistory.length - 2].d;
                        
                        console.log(`üö® ${p.n} CRASH DETECTED! Type: ${crashType}, Amount: ${crashAmount.toFixed(2)}, Recovering: ${isRecovering}`);
                        
                        if (isRecovering) {
                            crashWarning = `üö® MAJOR ${crashType} CRASH DETECTED! üö®\n`;
                            crashWarning += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                            crashWarning += `‚ö†Ô∏è This pet recently crashed in ${crashType.toLowerCase()}!\n`;
                            crashWarning += `üìâ Peak ‚Üí Current Drop: ${crashAmount.toFixed(2)}\n\n`;
                            crashWarning += `üìà RECOVERY IN PROGRESS:\n`;
                            crashWarning += `The pet has started rising again, but be cautious.\n`;
                            crashWarning += `A crash this large often signals market instability.\n`;
                            crashWarning += `Trade with EXTREME caution.\n\n`;
                        } else {
                            crashWarning = `üö® MAJOR ${crashType} CRASH DETECTED! üö®\n`;
                            crashWarning += `‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n`;
                            crashWarning += `‚ö†Ô∏è This pet dropped significantly in ${crashType.toLowerCase()}!\n`;
                            crashWarning += `üìâ Total Drop: ${crashAmount.toFixed(2)}\n`;
                            crashWarning += `‚ùå NO RECOVERY YET - AVOID TRADING!\n\n`;
                        }
                    }
                }
            } catch (histErr) {
                console.error("History check failed for", p.n, histErr);
            }
        }
        
        const generateSentence = (str, label) => {
            if (!str || typeof str !== 'string' || str.trim() === "") return null;
            let parts = str.trim().split(' ');
            if (parts.length < 2) return null;
            
            let icon = parts[0]; 
            let sentences = [];
            for (let i = 1; i < parts.length; i++) {
                let segment = parts[i];
                if (!segment.includes(':')) continue;
                let [tierKey, val] = segment.split(':');
                let tierName = (tierKey === 'Ne' ? 'Neon' : (tierKey === 'M' ? 'Mega' : 'Normal'));
                let actionWord = val.includes('+') ? 'INCREASED' : 'DECREASED';
                let amount = val.replace(/[+-]/g, "").replace(/[VD]$/g, "");
                sentences.push(`‚Ä¢ ${tierName} ${p.n} ${label} ${actionWord} BY ${amount}`);
            }
            return { icon, text: sentences.join('\n') };
        };
        
        // FIXED: Trend icons show ONLY their trend data (no crash warning)
        const vData = generateSentence(p.vt, "Value");
        if (vData) html += `<span title="${vData.text}" style="margin-left:4px; cursor:help; font-size:1.2em; filter: drop-shadow(0 0 2px #fff);">${vData.icon}</span>`;
        
        const dData = generateSentence(p.dt, "Demand");
        if (dData) html += `<span title="${dData.text}" style="margin-left:4px; cursor:help; font-size:1.2em; filter: drop-shadow(0 0 2px #fff);">${dData.icon}</span>`;
        
        // FIXED: Crash siren shows ONLY crash warning (separate from trend icons)
        if (crashWarning) {
            console.log(`‚úÖ Adding crash siren for ${p.n}`);
            html += `<span title="${crashWarning}" style="margin-left:4px; cursor:help; font-size:1.4em; color:#ef4444; filter: drop-shadow(0 0 4px #ef4444); animation: pulse 2s infinite;">üö®</span>`;
        }
        
    } catch (err) { 
        console.error("getTrendIcons error:", err);
        return ""; 
    }
    return html;
}
        async function fetchHistory() {
    if (HISTORY_DATA.length > 0) {
        console.log("üì¶ History already loaded:", HISTORY_DATA.length, "records");
        return;
    }
    
    try {
        console.log("üîÑ Fetching history from:", HISTORY_CSV_URL);
        const response = await fetch(HISTORY_CSV_URL + "&t=" + Date.now());
        
        if (!response.ok) {
            throw new Error(`HTTP ${response.status}: ${response.statusText}`);
        }
        
        const text = await response.text();
        console.log("üìÑ Raw CSV received, length:", text.length);
        
        const lines = text.trim().split('\n');
        console.log("üìä Total lines in CSV:", lines.length);
        
        if (lines.length < 2) {
            console.warn("‚ö†Ô∏è No history data rows (only header or empty)");
            return;
        }
        
        // Get headers to map columns correctly
        const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
        console.log("üìä Headers:", headers);
        
        // Parse with ALL columns preserved
        HISTORY_DATA = lines.slice(1).map((line, index) => {
            const vals = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
            const row = {};
            
            headers.forEach((header, i) => {
                const val = vals[i]?.trim() || '';
                // Convert numbers, keep strings as-is
                row[header] = (!isNaN(parseFloat(val)) && isFinite(val) && val !== '') 
                    ? parseFloat(val) 
                    : val;
            });
            
            // Log first row for debugging
            if (index === 0) {
                console.log("üìä Sample row:", row);
            }
            
            return row;
        }).filter(row => row.name || row['pet name']); // Support both column names
        
        console.log("‚úÖ History loaded successfully:", HISTORY_DATA.length, "records");
        buildManipCache();    // pre-compute manipulation flags
        buildDynamicHTT();    // build dynamic HTT from live demand/trend data
        buildTradeFreqMap();  // build trade frequency index from history
        trendVelocityCache.clear(); // clear any stale trend velocity cache
        
    } catch (e) { 
        console.error("‚ùå History fetch failed:", e);
        HISTORY_DATA = [];
    }
}

        // Pre-computed manipulation cache ‚Äî built once, looked up instantly
        const manipCache = new Map();
        function buildManipCache() {
            manipCache.clear();
            // Group history by pet name
            const byPet = {};
            HISTORY_DATA.forEach(p => {
                const name = (p.name || p['pet name'] || '').toLowerCase().trim();
                if (!name) return;
                if (!byPet[name]) byPet[name] = [];
                byPet[name].push(p);
            });
            Object.entries(byPet).forEach(([name, records]) => {
                if (records.length < 5) return;
                const values  = records.map(p => parseFloat(p.v) || 0).filter(v => v > 0);
                const demands = records.map(p => parseFloat(p.d) || 0).filter(d => d > 0);
                if (values.length < 5 || demands.length < 5) return;
                const firstVal  = values[0];
                const lastVal   = values[values.length - 1];
                const valueRise = ((lastVal - firstVal) / firstVal) * 100;
                if (valueRise < 25) return;
                const earlyDemands  = demands.slice(0, Math.floor(demands.length * 0.4));
                const overallAvgDem = demands.reduce((a,b)=>a+b,0) / demands.length;
                const earlyAvgDem   = earlyDemands.reduce((a,b)=>a+b,0) / earlyDemands.length;
                if (earlyAvgDem <= 4 && overallAvgDem <= 5) {
                    // Calculate day span
                    let dayInfo = '';
                    const timestamps = records.map(p => p.timestamp || p.time || '').filter(Boolean);
                    if (timestamps.length >= 2) {
                        const t0 = new Date(timestamps[0]), t1 = new Date(timestamps[timestamps.length-1]);
                        if (!isNaN(t0) && !isNaN(t1)) {
                            const days = Math.round(Math.abs(t1-t0)/86400000);
                            if (days > 0) dayInfo = ` in ~${days} days`;
                        }
                    }
                    manipCache.set(name, `Value rose +${valueRise.toFixed(0)}%${dayInfo} while demand stayed low (avg ${overallAvgDem.toFixed(1)}) ‚Äî may be manipulated, verify before trading`);
                }
            });
            console.log(`üîç Manipulation cache built: ${manipCache.size} flagged pets`);
        }
        function closeGraph() { document.getElementById('graphOverlay').style.display = 'none'; }
        async function openGraph(petData) {
    await fetchHistory();
    
    // Extract name and type from the petData object
    const name = petData.n;
    const type = petData.type || 'reg';
    const isFly = petData.f_st || false;
    const isRide = petData.r_st || false;
    
    // Determine which columns to use based on type and potions
    // Determine which columns to use based ONLY on type (Neon/Mega/Normal)
    // Ignore Fly/Ride variants - always use base version
    let demandKey = 'd';
    let valueKey = 'v';
    
    if (type === 'neon') {
        demandKey = 'nd';
        valueKey = 'n_v';
    } else if (type === 'mega') {
        demandKey = 'md';
        valueKey = 'm_v';
    } else {
        // Normal (base version, no fly/ride)
        demandKey = 'd';
        valueKey = 'v';
    }
    
    // Filter history for this specific pet (case insensitive)
    const petHistory = HISTORY_DATA.filter(p => {
        const histName = (p.name || p['pet name'] || '').toLowerCase().trim();
        return histName === name.toLowerCase().trim();
    });
    
    if (petHistory.length < 2) {
        alert(`Not enough historical data for ${name}.\n\nFound ${petHistory.length} record(s).`);
        return;
    }
    
    // Create title with version info
    // Create title with version info (ONLY Neon/Mega/Normal - ignore Fly/Ride)
    let versionText = type === 'neon' ? 'NEON ' : (type === 'mega' ? 'MEGA ' : 'NORMAL ');
    
    // Override valueKey to use base values (ignore fly/ride variants)
    if (type === 'neon') {
        valueKey = 'n_v';
    } else if (type === 'mega') {
        valueKey = 'm_v';
    } else {
        valueKey = 'v';
    }
    
    document.getElementById('graphTitle').innerText = versionText + name.toUpperCase();
    document.getElementById('graphOverlay').style.display = 'flex';
    
    const ctx = document.getElementById('petChart').getContext('2d');
    if (petChart) petChart.destroy();
    
    // Extract the correct data using the determined keys
    const demandData = petHistory.map(p => p[demandKey] || p.d || 0);
    const valueData = petHistory.map(p => p[valueKey] || p.v || 0);
    
    console.log(`üìä Graphing ${name} (${versionText})`);
    console.log(`üìä Using demand key: ${demandKey}, value key: ${valueKey}`);
    console.log(`üìä Sample values - Demand: ${demandData[0]}, Value: ${valueData[0]}`);
    
    const dataPointCount = valueData.length;
    const firstValue = valueData[0];
    const lastValue = valueData[valueData.length - 1];
    const minValue = Math.min(...valueData);
    const maxValue = Math.max(...valueData);
    const firstDemand = demandData[0];
    const lastDemand = demandData[demandData.length - 1];
    const avgDemand = demandData.reduce((a, b) => a + b, 0) / demandData.length;
    const peakDemand = Math.max(...demandData);
    const lowestDemand = Math.min(...demandData);
    
    // OVERALL TREND (entire dataset)
    const overallValueChange = lastValue - firstValue;
    const overallValueChangePercent = ((overallValueChange / firstValue) * 100);
    const overallDemandChange = lastDemand - firstDemand;
    const overallDemandChangePercent = firstDemand > 0 ? ((overallDemandChange / firstDemand) * 100) : 0;
    
    // RECENT TREND (last 25% of data vs previous 75%)
    const splitPoint = Math.floor(dataPointCount * 0.75);
    const recentValues = valueData.slice(splitPoint);
    const olderValues = valueData.slice(0, splitPoint);
    const recentAvg = recentValues.reduce((a, b) => a + b, 0) / recentValues.length;
    const olderAvg = olderValues.reduce((a, b) => a + b, 0) / olderValues.length;
    const recentTrendChange = ((recentAvg - olderAvg) / olderAvg) * 100;
    
    const recentDemands = demandData.slice(splitPoint);
    const olderDemands = demandData.slice(0, splitPoint);
    const recentDemandAvg = recentDemands.reduce((a, b) => a + b, 0) / recentDemands.length;
    const olderDemandAvg = olderDemands.reduce((a, b) => a + b, 0) / olderDemands.length;
    const recentDemandTrendChange = olderDemandAvg > 0 ? ((recentDemandAvg - olderDemandAvg) / olderDemandAvg) * 100 : 0;
    
    // MOMENTUM DETECTION (is trend accelerating or decelerating?)
    let momentum = 'neutral';
    if (dataPointCount >= 6) {
        const third = Math.floor(dataPointCount / 3);
        const early = valueData.slice(0, third);
        const mid = valueData.slice(third, third * 2);
        const late = valueData.slice(third * 2);
        const earlyAvg = early.reduce((a, b) => a + b, 0) / early.length;
        const midAvg = mid.reduce((a, b) => a + b, 0) / mid.length;
        const lateAvg = late.reduce((a, b) => a + b, 0) / late.length;
        const earlySlope = midAvg - earlyAvg;
        const lateSlope = lateAvg - midAvg;
        if (Math.abs(lateSlope) > Math.abs(earlySlope) * 1.3) {
            momentum = lateSlope > 0 ? 'accelerating upward' : 'accelerating downward';
        } else if (Math.abs(lateSlope) < Math.abs(earlySlope) * 0.7) {
            momentum = 'decelerating';
        }
    }
    
    // VOLATILITY ANALYSIS
    const volatilityRange = maxValue - minValue;
    const volatilityPercent = ((volatilityRange / firstValue) * 100);
    let valueFluctuations = 0;
    let upMoves = 0;
    let downMoves = 0;
    for (let i = 1; i < valueData.length; i++) {
        const change = valueData[i] - valueData[i-1];
        valueFluctuations += Math.abs(change);
        if (change > 0) upMoves++;
        else if (change < 0) downMoves++;
    }
    const avgFluctuation = valueFluctuations / (valueData.length - 1);
    const isVolatile = volatilityPercent > 20 || avgFluctuation > firstValue * 0.05;
    const volatilityBias = upMoves > downMoves * 1.3 ? 'upward' : downMoves > upMoves * 1.3 ? 'downward' : 'neutral';
    
    // PEAK DETECTION
    const isNearPeak = lastValue >= maxValue * 0.95;
    const isNearBottom = lastValue <= minValue * 1.05;
    
    // ‚îÄ‚îÄ REAL DATE/TIME PARSING ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    // Tries multiple common date formats from the CSV timestamps
    function parseTimestamp(raw) {
        if (!raw || typeof raw !== 'string') return null;
        const s = raw.trim();
        // Try native parse first (ISO, MM/DD/YYYY, etc.)
        let d = new Date(s);
        if (!isNaN(d)) return d;
        // Try DD/MM/YYYY
        const dmy = s.match(/^(\d{1,2})\/(\d{1,2})\/(\d{2,4})$/);
        if (dmy) { d = new Date(`${dmy[3]}-${dmy[2].padStart(2,'0')}-${dmy[1].padStart(2,'0')}`); if (!isNaN(d)) return d; }
        // Try Month DD (e.g. "Jan 5" or "January 5")
        const monthDay = s.match(/^([A-Za-z]+)\s+(\d{1,2}),?\s*(\d{4})?$/);
        if (monthDay) { d = new Date(`${monthDay[1]} ${monthDay[2]} ${monthDay[3] || new Date().getFullYear()}`); if (!isNaN(d)) return d; }
        return null;
    }

    const rawTimestamps = petHistory.map(p => p.timestamp || p.time || p.date || '');
    const parsedDates   = rawTimestamps.map(parseTimestamp);
    const validDates    = parsedDates.filter(d => d !== null);
    const hasRealDates  = validDates.length >= 2;

    let totalDaysSpan     = null;
    let avgDaysBetweenPoints = null;
    let isSparseData      = false;
    let timeSpan          = 'unknown timeframe';
    let perDayValueChange = null;   // absolute value change per day
    let recentDaysWindow  = null;   // how many calendar days the "recent" slice covers

    if (hasRealDates) {
        const firstDate = validDates[0];
        const lastDate  = validDates[validDates.length - 1];
        const MS_PER_DAY = 86400000;
        totalDaysSpan = Math.round((lastDate - firstDate) / MS_PER_DAY);
        avgDaysBetweenPoints = dataPointCount > 1 ? totalDaysSpan / (dataPointCount - 1) : 0;
        isSparseData = avgDaysBetweenPoints > 14; // more than 2 weeks between updates = sparse

        // Per-day rate of value change
        if (totalDaysSpan > 0) {
            perDayValueChange = overallValueChange / totalDaysSpan;
        }

        // How many days does the "recent" slice cover?
        const splitDateIdx = Math.floor(validDates.length * 0.75);
        if (splitDateIdx < validDates.length) {
            recentDaysWindow = Math.round((lastDate - validDates[splitDateIdx]) / MS_PER_DAY);
        }

        // Human-readable span
        if (totalDaysSpan < 7) timeSpan = `past ${totalDaysSpan} day${totalDaysSpan !== 1 ? 's' : ''}`;
        else if (totalDaysSpan < 30) timeSpan = `past ${Math.round(totalDaysSpan / 7)} week${Math.round(totalDaysSpan / 7) !== 1 ? 's' : ''}`;
        else if (totalDaysSpan < 365) timeSpan = `past ${Math.round(totalDaysSpan / 30)} month${Math.round(totalDaysSpan / 30) !== 1 ? 's' : ''}`;
        else timeSpan = `past ${(totalDaysSpan / 365).toFixed(1)} year${totalDaysSpan > 500 ? 's' : ''}`;
    } else {
        // No parseable dates ‚Äî fall back to point-count language
        timeSpan = `across ${dataPointCount} recorded update${dataPointCount !== 1 ? 's' : ''}`;
    }

    // CONFIDENCE SCORE ‚Äî now based on days & density, not just count
    let confidence = 'LOW';
    let confidenceNote = '';
    if (hasRealDates) {
        if (totalDaysSpan >= 60 && dataPointCount >= 8 && !isSparseData) {
            confidence = 'HIGH';
            confidenceNote = `${dataPointCount} points over ${totalDaysSpan} days`;
        } else if (totalDaysSpan >= 21 && dataPointCount >= 5) {
            confidence = 'MEDIUM';
            confidenceNote = `${dataPointCount} points over ${totalDaysSpan} days`;
            if (isSparseData) confidenceNote += ' (sparse ‚Äî avg ' + Math.round(avgDaysBetweenPoints) + 'd between updates)';
        } else {
            confidence = 'LOW';
            confidenceNote = `only ${totalDaysSpan} days of data`;
            if (isSparseData) confidenceNote += ', sparsely recorded';
        }
    } else {
        if (dataPointCount >= 20) confidence = 'MEDIUM';
        confidenceNote = `${dataPointCount} data point${dataPointCount !== 1 ? 's' : ''}, no parseable timestamps`;
    }
    
    // BUILD TREND TEXT (date-aware)
    let trendText = '';

    let overallDirection = overallValueChangePercent > 10 ? 'Strong upward' :
                          overallValueChangePercent > 5  ? 'Moderate upward' :
                          overallValueChangePercent > 2  ? 'Slight upward' :
                          overallValueChangePercent < -10? 'Sharp downward' :
                          overallValueChangePercent < -5 ? 'Moderate downward' :
                          overallValueChangePercent < -2 ? 'Slight downward' : 'Stable';

    trendText = `<strong>${overallDirection}</strong> overall trend (${timeSpan}): ${firstValue.toFixed(2)} ‚Üí ${lastValue.toFixed(2)} (<span style="color: ${overallValueChangePercent >= 0 ? 'var(--win)' : 'var(--lose)'};">${overallValueChangePercent > 0 ? '+' : ''}${overallValueChangePercent.toFixed(1)}%</span>). `;

    // Show per-day rate of change if we have real dates
    if (perDayValueChange !== null && totalDaysSpan > 3) {
        const pdSign = perDayValueChange >= 0 ? '+' : '';
        trendText += `Rate of change: <strong style="color:${perDayValueChange >= 0 ? 'var(--win)' : 'var(--lose)'};">${pdSign}${perDayValueChange.toFixed(3)} value/day</strong>. `;
    }

    // Sparse data warning
    if (hasRealDates && isSparseData) {
        trendText += `<span style="color:var(--trap)">‚ö†Ô∏è Sparse data ‚Äî recorded roughly every ${Math.round(avgDaysBetweenPoints)} days, so short-term moves may be invisible.</span> `;
    }

    // Recent trend comparison ‚Äî only show if recent window is meaningful in days
    const recentWindowLabel = (hasRealDates && recentDaysWindow !== null)
        ? (recentDaysWindow < 7 ? `last ${recentDaysWindow}d` : `last ~${Math.round(recentDaysWindow/7)}wk`)
        : 'recent';
    if (Math.abs(recentTrendChange - overallValueChangePercent) > 5) {
        if (recentTrendChange > 0 && overallValueChangePercent < 0) {
            trendText += `<strong style="color: var(--win);">üîÑ RECOVERING (${recentWindowLabel}):</strong> Up <span style="color: var(--win);">+${recentTrendChange.toFixed(1)}%</span> despite overall decline. `;
        } else if (recentTrendChange < -5 && overallValueChangePercent > 0) {
            trendText += `<strong style="color: var(--lose);">‚ö†Ô∏è WEAKENING (${recentWindowLabel}):</strong> Down <span style="color: var(--lose);">${recentTrendChange.toFixed(1)}%</span> despite overall growth. `;
        } else if (recentTrendChange > overallValueChangePercent + 5) {
            trendText += `<strong style="color: var(--win);">üìà MOMENTUM BUILDING (${recentWindowLabel}):</strong> <span style="color: var(--win);">+${recentTrendChange.toFixed(1)}%</span> stronger than overall trend. `;
        }
    }

    // Demand analysis
    let demandStatus = lastDemand >= 8 ? 'excellent' : lastDemand >= 6 ? 'strong' : lastDemand >= 4 ? 'moderate' : lastDemand >= 2 ? 'weak' : 'very poor';
    trendText += `Demand is <strong style="color: ${getDemandColor(lastDemand)};">${demandStatus} (${lastDemand.toFixed(1)})</strong>`;
    if (Math.abs(overallDemandChangePercent) > 10) {
        trendText += `, ${overallDemandChangePercent > 0 ? 'up' : 'down'} ${Math.abs(overallDemandChangePercent).toFixed(1)}% from ${firstDemand.toFixed(1)}`;
    }
    trendText += '. ';

    // Peak/bottom ‚Äî only assert if data covers enough days
    const enoughDaysForPeak = !hasRealDates ? (dataPointCount >= 10) : (totalDaysSpan >= 30);
    if (isNearPeak && enoughDaysForPeak) {
        trendText += `<strong style="color: var(--trap);">‚ö†Ô∏è Near recorded high</strong> (${lastValue.toFixed(2)} vs peak ${maxValue.toFixed(2)} over ${timeSpan}). `;
    } else if (isNearPeak) {
        trendText += `Currently at the top of its <em>recent</em> range ‚Äî not enough history to call this an all-time high. `;
    }
    if (isNearBottom && enoughDaysForPeak) {
        trendText += `<strong>Near recorded low</strong> (${lastValue.toFixed(2)} vs bottom ${minValue.toFixed(2)} over ${timeSpan}). `;
    } else if (isNearBottom) {
        trendText += `At the bottom of its recent recorded range. `;
    }

    // Volatility
    if (isVolatile) {
        trendText += `<strong style="color: var(--trap);">High volatility</strong> (${volatilityPercent.toFixed(1)}% swing${hasRealDates ? ' over ' + timeSpan : ''}) with ${volatilityBias} bias. `;
    }

    // Momentum
    if (momentum !== 'neutral') {
        trendText += `Trend is <strong>${momentum}</strong>. `;
    }
    
    // ===================================================
    // Feature 7: Overhauled Trend Analysis & Recommendations
    // Uses real date/day calculations where available
    // ===================================================
    let recommendation = '';
    let recommendColor = 'white';

    const catStr     = (petData.cat || '').toLowerCase();
    const isHighTier = catStr.includes('high tier') || catStr.includes('preppy') || catStr.includes('exotic');
    const isRandom   = catStr.includes('random') || catStr.includes('common') || catStr.includes('uncommon');

    // Noise threshold ‚Äî scale based on actual days if available
    const noiseValPct  = hasRealDates && totalDaysSpan < 14 ? 5 : 3;
    const isSmallFluctuation = Math.abs(overallValueChangePercent) < noiseValPct && Math.abs(overallDemandChange) < 0.5;

    // Genuine peak/low requires meaningful time coverage
    const enoughHistory      = hasRealDates ? totalDaysSpan >= 30 : dataPointCount >= 10;
    const genuineHistoricalHigh = enoughHistory && isNearPeak;
    const genuineHistoricalLow  = enoughHistory && isNearBottom;

    // Limited data: less than 5 points OR less than 7 days if we have dates
    const limitedData = hasRealDates ? (totalDaysSpan < 7 || dataPointCount < 3) : dataPointCount < 5;

    // "Strong" trend requires meaningful time to confirm ‚Äî a 10% move in 2 days is less reliable than over 2 weeks
    const sustainedUptrend  = overallValueChangePercent > 10 && recentTrendChange > 5
                              && (!hasRealDates || totalDaysSpan >= 14);
    const sustainedDowntrend = overallValueChangePercent < -8 && recentTrendChange < -3
                              && (!hasRealDates || totalDaysSpan >= 14);

    if (limitedData) {
        // Not enough data ‚Äî don't make dramatic claims
        if (lastDemand >= 7) {
            recommendation = 'üìä Limited data ‚Äî not enough history for confident analysis. Demand looks solid right now.';
            recommendColor = 'var(--subtext)';
        } else if (lastDemand >= 4) {
            recommendation = 'üìä Limited data ‚Äî only ' + dataPointCount + ' point(s) available. Current demand is average. Trade carefully.';
            recommendColor = 'var(--subtext)';
        } else {
            recommendation = 'üìä Limited data with low demand. Insufficient history to judge trend ‚Äî approach with caution.';
            recommendColor = 'var(--trap)';
        }
    } else if (isSmallFluctuation) {
        // Minor noise, don't over-react
        if (lastDemand >= 7) {
            recommendation = '‚úÖ Short-term fluctuation in a high-demand pet ‚Äî long-term stable. Good time to trade for or hold.';
            recommendColor = 'var(--win)';
        } else if (lastDemand >= 4) {
            recommendation = '‚û°Ô∏è Minor noise ‚Äî value and demand are essentially flat. Neutral outlook; neither rush to trade nor avoid.';
            recommendColor = 'white';
        } else {
            recommendation = '‚ö†Ô∏è Stable but weak demand. Low trading velocity ‚Äî consider whether you can move this pet before acquiring.';
            recommendColor = 'var(--trap)';
        }
    } else if (genuineHistoricalHigh) {
        // Confirmed near peak across many data points
        if (isHighTier && lastDemand >= 7 && momentum === 'accelerating upward') {
            recommendation = '‚ö†Ô∏è High-Tier pet at confirmed multi-week peak with strong demand. Could continue rising, but risk of correction is real. Advanced traders only ‚Äî consider holding rather than trading away.';
            recommendColor = 'var(--trap)';
        } else if (isHighTier) {
            recommendation = '‚ö†Ô∏è High-Tier pet at genuine historical high (' + dataPointCount + ' data points). Consider holding rather than trading away ‚Äî re-entry after a dip may be costly.';
            recommendColor = 'var(--trap)';
        } else {
            recommendation = '‚ö†Ô∏è At confirmed historical high. High risk of pullback. Wait for a dip before acquiring.';
            recommendColor = 'var(--trap)';
        }
    } else if (genuineHistoricalLow) {
        // Confirmed near bottom
        if (lastDemand >= 5 && recentTrendChange > 0) {
            recommendation = '‚úÖ Short-term dip, long-term stable ‚Äî this is a reasonable time to trade for. Demand is healthy and recent trend is recovering.';
            recommendColor = 'var(--win)';
        } else if (lastDemand >= 5) {
            recommendation = '‚ö†Ô∏è Near confirmed historical low. Demand is ok, but value has not started recovering yet ‚Äî wait 1‚Äì2 more data cycles for confirmation.';
            recommendColor = 'var(--trap)';
        } else {
            recommendation = '‚ùå Near historical low with weak demand. Both value and interest are depressed ‚Äî avoid until signs of recovery.';
            recommendColor = 'var(--lose)';
        }
    } else if (sustainedUptrend) {
        // Strong, confirmed multi-day uptrend
        const dayCtx = hasRealDates ? ` over ${totalDaysSpan} days` : '';
        if (isHighTier && lastDemand >= 7) {
            recommendation = `üî• Strong uptrend in a High-Tier pet${dayCtx} ‚Äî consider holding rather than trading away. If acquiring, excellent long-term pick.`;
            recommendColor = 'var(--win)';
        } else if (lastDemand >= 6) {
            recommendation = `üî• Sustained uptrend${dayCtx} with solid demand. Good acquisition ‚Äî momentum is confirmed, not a blip.`;
            recommendColor = 'var(--win)';
        } else {
            recommendation = `‚ö†Ô∏è Value rising${dayCtx} but demand is below average. Possible value trap ‚Äî verify interest before committing.`;
            recommendColor = 'var(--trap)';
        }
    } else if (sustainedDowntrend) {
        // Confirmed sustained decline
        const dayCtx = hasRealDates ? ` over ${totalDaysSpan} days` : '';
        if (recentDemandTrendChange > 15 && lastDemand >= 6) {
            const watchTime = hasRealDates ? `${Math.max(7, Math.round(totalDaysSpan * 0.2))} more days` : '1‚Äì2 more weeks';
            recommendation = `‚ö†Ô∏è Value dropping${dayCtx} but demand recently spiked. Conflicting signals ‚Äî watch for ${watchTime} before deciding.`;
            recommendColor = 'var(--trap)';
        } else if (isHighTier) {
            recommendation = `‚ö†Ô∏è High-Tier pet in a confirmed downtrend${dayCtx}. Don't panic-trade ‚Äî these often stabilise. Wait for value to flatten.`;
            recommendColor = 'var(--trap)';
        } else {
            recommendation = `‚ùå Sustained value decline${dayCtx} with no reversal. Avoid acquiring. Trade away if you own it.`;
            recommendColor = 'var(--lose)';
        }
    } else if (overallValueChangePercent < -5 && recentTrendChange > 4) {
        // Declined overall but recently recovering
        recommendation = '‚ö†Ô∏è Short-term dip with recent recovery signals ‚Äî watch for 1 more week to confirm reversal before trading for.';
        recommendColor = 'var(--trap)';
    } else if (isVolatile) {
        if (volatilityBias === 'upward' && lastDemand >= 6) {
            recommendation = '‚ö†Ô∏è Volatile but upward-biased with decent demand. Higher risk, but real upside. Only for experienced traders.';
            recommendColor = 'var(--trap)';
        } else if (volatilityBias === 'downward') {
            recommendation = '‚ùå High volatility with downward bias. Unpredictable and risky ‚Äî avoid unless you have a specific strategy.';
            recommendColor = 'var(--lose)';
        } else {
            recommendation = '‚ö†Ô∏è Chaotic price action with no clear direction. Risky entry point ‚Äî wait for the pattern to settle.';
            recommendColor = 'var(--trap)';
        }
    } else if (lastDemand >= 7 && Math.abs(overallValueChangePercent) <= 5) {
        recommendation = '‚úÖ Stable value with strong demand ‚Äî a reliable, liquid pet. Safe to hold or trade; easy to move when needed.';
        recommendColor = 'var(--win)';
    } else if (lastDemand < 3) {
        recommendation = '‚ùå Very low demand regardless of price action. Hard to find interested traders ‚Äî poor liquidity. Avoid unless you intend to keep it.';
        recommendColor = 'var(--lose)';
    } else {
        // Fallback moderate cases
        if (overallValueChangePercent >= 3) {
            recommendation = '‚úÖ Modest, steady growth with average demand. Decent choice for patient traders; not a high-velocity pick.';
            recommendColor = 'var(--win)';
        } else if (overallValueChangePercent >= -3) {
            recommendation = '‚û°Ô∏è Value is flat with moderate demand. Neutral outlook ‚Äî fine to hold, no urgent action needed.';
            recommendColor = 'white';
        } else {
            recommendation = '‚ö†Ô∏è Slight decline in value with low-moderate demand. Not alarming, but not ideal. Monitor before committing.';
            recommendColor = 'var(--trap)';
        }
    }
    
    // Add confidence score with date context
    trendText += `<br><br><em style="color: var(--subtext); font-size: 0.85em;">Analysis confidence: <strong>${confidence}</strong> ‚Äî ${confidenceNote}</em>`;
    
    document.getElementById('trendAnalysis').innerHTML = `<strong style="color: var(--accent);">üìä Trend Analysis:</strong><br>${trendText}<br><br><strong style="color: var(--frost);">Recommendation:</strong> <span style="color: ${recommendColor};">${recommendation}</span>`;
    
    petChart = new Chart(ctx, {
        type: 'line',
        data: {
            labels: petHistory.map(p => p.timestamp || p.time || ''),
            datasets: [
                {
                    label: `Value (${versionText.trim()})`,
                    data: valueData,
                    borderColor: '#38bdf8',
                    backgroundColor: 'rgba(56, 189, 248, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.3
                },
                {
                    label: `Demand (${type === 'neon' ? 'Neon' : type === 'mega' ? 'Mega' : 'Normal'})`,
                    data: demandData,
                    borderColor: '#fbbf24',
                    backgroundColor: 'rgba(251, 191, 36, 0.1)',
                    borderWidth: 3,
                    fill: true,
                    tension: 0.3
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            scales: {
                y: { 
                    grid: { color: '#334155' }, 
                    ticks: { color: '#94a3b8' },
                    beginAtZero: false
                },
                x: { 
                    grid: { display: false }, 
                    ticks: { color: '#94a3b8', maxRotation: 45, minRotation: 45 } 
                }
            },
            plugins: {
                legend: { 
                    labels: { color: 'white', font: { weight: 'bold', size: 14 } } 
                },
                tooltip: {
                    callbacks: {
                        label: function(context) {
                            return `${context.dataset.label}: ${context.parsed.y.toFixed(2)}`;
                        }
                    }
                }
            }
        }
    });
}
        // CONTINUE WITH THE REST OF YOUR ORIGINAL FUNCTIONS HERE
        // (handlePetContext, openInfo, closeInfo, playSfx, pushState, undo, parseCSV, etc.)
        function handlePetContext(e, petData) {
    e.preventDefault();
    if (e.shiftKey) {
        openGraph(petData);
    } else {
        openQtyModal(petData.n);
    }
}

        function openInfo() { document.getElementById('infoOverlay').style.display = 'flex'; }
        function closeInfo() { document.getElementById('infoOverlay').style.display = 'none'; }

        const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
        function playSfx(type) {
            if (audioCtx.state === 'suspended') audioCtx.resume();
            const osc = audioCtx.createOscillator();
            const gain = audioCtx.createGain();
            osc.connect(gain);
            gain.connect(audioCtx.destination);
            if (type === 'pop') {
                osc.frequency.setValueAtTime(600, audioCtx.currentTime);
                osc.frequency.exponentialRampToValueAtTime(150, audioCtx.currentTime + 0.1);
                gain.gain.setValueAtTime(0.15, audioCtx.currentTime);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.1);
            } else if (type === 'win') {
                osc.type = 'triangle';
                [523, 659, 783].forEach((f, i) => osc.frequency.setValueAtTime(f, audioCtx.currentTime + (i * 0.1)));
                gain.gain.setValueAtTime(0.04, audioCtx.currentTime);
                osc.start();
                osc.stop(audioCtx.currentTime + 0.4);
            }
        }

        let redoStack = [];

        function pushState() {
            if (history.length > 50) history.shift();
            history.push(JSON.stringify({ A: state.A, B: state.B, inv: state.inv }));
            redoStack = []; // any new action clears redo
        }

        function undo() {
            if (history.length === 0) return;
            // Save current state to redo stack before reverting
            redoStack.push(JSON.stringify({ A: state.A, B: state.B, inv: state.inv }));
            if (redoStack.length > 50) redoStack.shift();
            const last = JSON.parse(history.pop());
            state.A = (last.A || []);
            state.B = (last.B || []);
            state.inv = (last.inv || []);
            render();
            renderInventory();
            saveTrade();
        }

        function redo() {
            if (redoStack.length === 0) return;
            history.push(JSON.stringify({ A: state.A, B: state.B, inv: state.inv }));
            const next = JSON.parse(redoStack.pop());
            state.A = (next.A || []);
            state.B = (next.B || []);
            state.inv = (next.inv || []);
            render();
            renderInventory();
            saveTrade();
        }

        window.addEventListener('keydown', (e) => {
            // Handle keybinds for pet shortcuts
            if (!e.ctrlKey && !e.altKey && !e.metaKey) {
                const bindKey = e.key.toUpperCase();
                const bind = state.keybinds.find(b => b.key === bindKey);
                if (bind && bind.petName) {
                    // Don't fire if user is typing in an input
                    if (['INPUT','TEXTAREA','SELECT'].includes(document.activeElement.tagName)) return;
                    e.preventDefault();
                    const pet = bind.source === 'inv'
                        ? state.inv.find(p => p.n === bind.petName)
                        : ALL_PETS.find(p => p.n === bind.petName);
                    if (pet) {
                        pushState();
                        state.A.push({ ...pet, uid: Date.now() + Math.random(), type: bind.type || 'reg', f_st: !!bind.f_st, r_st: !!bind.r_st });
                        render();
                        saveTrade();
                    }
                    return;
                }
            }
            if (e.ctrlKey && e.key === 'z') { e.preventDefault(); undo(); }
            if (e.ctrlKey && e.key === 'y') { e.preventDefault(); redo(); }
        });

        function parseCSV(text) {
            const lines = text.trim().split('\n');
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            return lines.slice(1).map(line => {
                const values = line.split(/,(?=(?:(?:[^"]*"){2})*[^"]*$)/);
                const obj = {};
                headers.forEach((header, i) => {
                    let val = values[i] ? values[i].trim().replace(/^"|"$/g, '') : '';
                    if (!isNaN(parseFloat(val)) && isFinite(val) && val !== '') {
                        obj[header] = parseFloat(val);
                    } else {
                        obj[header] = val;
                    }
                });
                return obj;
            });
        }

        function saveTrade() {
            const simplifiedState = {
                A: state.A.map(p => ({ n: p.n, type: p.type, f_st: p.f_st, r_st: p.r_st, uid: p.uid })),
                B: state.B.map(p => ({ n: p.n, type: p.type, f_st: p.f_st, r_st: p.r_st, uid: p.uid })),
                inv: state.inv.map(p => ({ n: p.n, type: p.type, f_st: p.f_st, r_st: p.r_st, uid: p.uid }))
            };
            localStorage.setItem('tradeData', JSON.stringify(simplifiedState));
        }

        function restoreTrade() {
            const saved = localStorage.getItem('tradeData');
            if (!saved) return;
            try {
                const parsed = JSON.parse(saved);
                const hydrate = (item) => {
                    const freshData = ALL_PETS.find(p => p.n === item.n);
                    if (!freshData) return null; 
                    return { ...freshData, ...item };
                };
                state.A = (parsed.A || []).map(hydrate).filter(x => x);
                state.B = (parsed.B || []).map(hydrate).filter(x => x);
                state.inv = (parsed.inv || []).map(hydrate).filter(x => x);
                render();
            } catch (e) {
                console.error("Failed to restore trade", e);
            }
        }

        async function loadPetData() {
            try {
                const response = await fetch(MASTER_CSV_URL + "&t=" + Date.now());
                const csvText = await response.text();
                const data = parseCSV(csvText);
                
                ALL_PETS = data.map(row => ({
                    n: row.n || row.name || '',
                    d: row.d || 0,
                    nd: row.nd || 0,
                    md: row.md || 0,
                    f: row.f || 0,
                    v: row.v || 0,
                    f_v: row.f_v || 0,
                    r_v: row.r_v || 0,
                    fr_v: row.fr_v || 0,
                    n_v: row.n_v || 0,
                    n_f_v: row.n_f_v || 0, 
                    n_r_v: row.n_r_v || 0, 
                    nfr_v: row.nfr_v || 0,
                    m_v: row.m_v || 0,
                    m_f_v: row.m_f_v || 0, 
                    m_r_v: row.m_r_v || 0, 
                    mfr_v: row.mfr_v || 0,
                    nfr_f: row.nfr_f || 0,
                    mfr_f: row.mfr_f || 0,
                    cat: (row.categories || row.rarity || '').toLowerCase(),
                    vt: row['value trend'] || row['vt'] || '', 
                    dt: row['demand trend'] || row['dt'] || ''
                })).filter(p => p.n && p.n.length > 0);
                
                document.getElementById('loadingScreen').style.display = 'none';
                buildDynamicHTT();  // initial HTT from pet data (before history)
                fetchHistory();
                restoreTrade();
                render();
                // Render lists if already on those tabs
                if (currentTab === 'value') renderValueList();
                if (currentTab === 'demand') renderDemandList();
            } catch (error) {
                console.error('Error loading data:', error);
                document.querySelector('.loading-text').textContent = 'Error loading data.';
            }
        }

        function openSearch(side) {
            state.target = side;
            document.getElementById('searchOverlay').classList.add('open');
            searchState.renderLimit = 50;
            filterAndRender(document.getElementById('mainSearch').value.toLowerCase());
            setTimeout(() => document.getElementById('mainSearch').focus(), 50);
        }

        function closeSearch() { document.getElementById('searchOverlay').classList.remove('open'); }

        function updateFilter() {
            searchState.sortMode = document.getElementById('sortSelect').value;
            searchState.rarityFilter = document.getElementById('rarityFilter').value.toLowerCase();
            searchState.renderLimit = 50; 
            filterAndRender(document.getElementById('mainSearch').value.toLowerCase());
        }

        document.getElementById('mainSearch').addEventListener('input', (e) => {
            searchState.renderLimit = 50; 
            filterAndRender(e.target.value.toLowerCase());
        });

        document.getElementById('searchResults').addEventListener('scroll', () => {
            const box = document.getElementById('searchResults');
            if (box.scrollTop + box.clientHeight >= box.scrollHeight - 50) {
                if (searchState.renderLimit < searchState.currentMatches.length) {
                    searchState.renderLimit += 50;
                    renderDOM(); 
                }
            }
        });

        function filterAndRender(query) {
            let matches = query === "" ? [...ALL_PETS] : ALL_PETS.filter(p => p.n.toLowerCase().includes(query));
            if (searchState.rarityFilter !== 'none') {
                matches = matches.filter(p => (p.cat || "").toLowerCase().includes(searchState.rarityFilter));
            }
            const mode = searchState.sortMode;
            if (mode !== 'default') {
                matches.sort((a, b) => {
                    if (mode === 'valHigh') return b.v - a.v;
                    if (mode === 'valLow') return a.v - b.v;
                    if (mode === 'demHigh') return b.d - a.d;
                    if (mode === 'demLow') return a.d - b.d;
                    return 0;
                });
            } else {
                // Feature 6: Smart sort by demand ‚Üí recent trend ‚Üí category
                matches = smartSortPets(matches, query);
            }
            searchState.currentMatches = matches;
            renderDOM();
        }

        function renderDOM() {
            const chunk = searchState.currentMatches.slice(0, searchState.renderLimit);
            const query = document.getElementById('mainSearch').value.toLowerCase();
            const resultsEl = document.getElementById('searchResults');

            // Feature 6: Trending Now section injected above the grid
            const trendingOuter = resultsEl.parentNode.querySelector('.trending-section-outer');
            if (query === '' && searchState.sortMode === 'default' && searchState.rarityFilter === 'none') {
                const trendingPets = getTrendingPets(5);
                if (trendingPets.length > 0) {
                    const pills = trendingPets.map(p => {
                        const icon = (p.dt && p.dt.includes('üî•')) ? 'üî•' : 'üìà';
                        return `<div class="trending-pill" onclick="addItem(null,'${p.n.replace(/'/g,"\\'")}',1)">${icon} ${p.n} <span style="opacity:0.6">¬∑ ${p.d}</span></div>`;
                    }).join('');
                    if (!trendingOuter) {
                        const wrapper = document.createElement('div');
                        wrapper.className = 'trending-section-outer';
                        wrapper.innerHTML = `<div class="trending-section"><div class="trending-title">‚ö° Trending Now</div><div class="trending-pills">${pills}</div></div>`;
                        resultsEl.parentNode.insertBefore(wrapper, resultsEl);
                    } else {
                        trendingOuter.querySelector('.trending-pills').innerHTML = pills;
                    }
                }
            } else {
                if (trendingOuter) trendingOuter.remove();
            }

            resultsEl.innerHTML = chunk.map(p => {
                const imgUrl = `https://amvgg.com/items/${encodeURIComponent(p.n)}.webp`;
                const imgTag = petImgTag(p.n, 'width:100%;height:100%;object-fit:contain');
                const val = calculatePetVal(p, 'value'); 
                const rarityColor = getRarityColor(p.cat);
                const demandColor = getDemandColor(p.d);
                return `
                <div class="search-item-card" 
                     onclick="addItem(this, '${p.n.replace(/'/g, "\\'")}', 1)" 
                     oncontextmenu="handlePetContext(event, ${JSON.stringify(p).replace(/"/g, '&quot;')})"
                     style="border-color: ${rarityColor}">
                    <div class="search-item-name">${p.n}${getTrendIcons(p)}</div>
                    <img src="${imgUrl}" class="search-item-img" onerror="petImgFallback(this)" data-fallbacks='[]' data-fb-idx="0">
                    <div class="search-item-val">${val ? val.toFixed(2) : 0}</div>
                    <div class="search-item-demand" style="color: ${demandColor}">Dem: ${p.d}</div>
                </div>`;
            }).join('');
        }

        function openQtyModal(name) {
            selectedPetForQty = name;
            document.getElementById('qtyTitle').innerText = `How many ${name}?`;
            document.getElementById('qtyInput').value = 1;
            document.getElementById('qtyModal').style.display = 'flex';
            setTimeout(() => document.getElementById('qtyInput').focus(), 50);
        }

        function closeQtyModal() {
            document.getElementById('qtyModal').style.display = 'none';
            selectedPetForQty = null;
        }

        function confirmQty() {
            const count = parseInt(document.getElementById('qtyInput').value);
            if (count > 0 && selectedPetForQty) {
                addItem(null, selectedPetForQty, count);
            }
            closeQtyModal();
        }

        function addItem(element, name, quantity = 1) {
            if (state.target !== 'inv' && state.target !== 'dream') {
                if ((state[state.target] ? state[state.target].length : 0) + quantity > 18) {
                    alert("Trade limit reached! Adopt Me only allows 18 items per trade.");
                    return;
                }
            }
            const pet = ALL_PETS.find(x => x.n === name);
            if (!pet) return;
            pushState();
            for (let i = 0; i < quantity; i++) {
                const newPet = { ...pet, uid: Math.random(), type: 'reg', f_st: false, r_st: false };
                if (state.target === 'inv') { state.inv.push(newPet); } 
                else if (state.target === 'dream') { state.dreamPet = newPet; } 
                else { state[state.target].push(newPet); }
            }
            if (state.target === 'inv') {
                renderInventory();
                if (element) {
                    element.classList.add('added');
                    setTimeout(() => element.classList.remove('added'), 500);
                }
            } else if (state.target === 'dream') {
                renderInventory();
                closeSearch();
            } else {
                render();
                closeSearch(); 
            }
            playSfx('pop'); saveTrade(); 
        }

        function duplicate(s, uid) {
            if (state[s].length >= 18 && s !== 'inv') return;
            pushState();
            const original = state[s].find(x => x.uid === uid);
            if (!original) return;
            const copy = { ...original, uid: Math.random() };
            state[s].push(copy);
            if (s === 'inv') renderInventory(); else render();
            playSfx('pop'); saveTrade(); 
        }

        function remove(s, uid) { 
            pushState();
            state[s] = state[s].filter(x => x.uid !== uid); 
            if (s === 'inv') renderInventory(); else render();
            saveTrade(); 
        }

        function openInventory() { document.getElementById('invOverlay').style.display = 'flex'; renderInventory(); }
        function closeInventory() { document.getElementById('invOverlay').style.display = 'none'; }

        function exportInv() {
            const data = JSON.stringify(state.inv);
            const encoded = btoa(unescape(encodeURIComponent(data))); 
            navigator.clipboard.writeText(encoded).then(() => {
                alert("Inventory code copied to clipboard!");
            });
        }

        function importInv() {
            const code = prompt("Paste your inventory code here:");
            if (!code) return;
            try {
                const decoded = decodeURIComponent(escape(atob(code)));
                const data = JSON.parse(decoded);
                const validData = data.filter(item => ALL_PETS.some(p => p.n === item.n));
                if (validData.length > 0) {
                    pushState();
                    state.inv = validData.map(item => ({...item, uid: Math.random()}));
                    renderInventory();
                    alert(`Successfully imported ${validData.length} items!`);
                    saveTrade();
                } else {
                    alert("Invalid data found. No items imported.");
                }
            } catch (e) {
                console.error(e);
                alert("Error importing data. Code might be invalid.");
            }
        }

        let rarityChartInst = null, catChartInst = null;
        function openAnalytics() {
            const overlay = document.getElementById('analyticsOverlay');
            const body = document.getElementById('analyticsBody');
            overlay.style.display = 'flex';
            const rarities = {}, categories = {};
            let total = state.inv.length;
            if (total === 0) {
                body.innerHTML = '<div style="text-align:center; color:#94a3b8;padding:40px">Inventory is empty.</div>';
                return;
            }
            // Total value by category
            const catValues = {};
            state.inv.forEach(p => {
                const r = (p.cat || 'unknown').toLowerCase();
                let rKey = 'Common';
                if(r.includes('legendary')) rKey = 'Legendary';
                else if(r.includes('ultra')) rKey = 'Ultra-Rare';
                else if(r.includes('rare')) rKey = 'Rare';
                else if(r.includes('uncommon')) rKey = 'Uncommon';
                rarities[rKey] = (rarities[rKey] || 0) + 1;
                let cKey = 'Randoms';
                if(r.includes('preppy')) cKey = 'Preppy';
                else if(r.includes('high tier')) cKey = 'High Tier';
                else if(r.includes('exotic')) cKey = 'Exotic';
                else if(r.includes('classy')) cKey = 'Classy';
                categories[cKey] = (categories[cKey] || 0) + 1;
                const v = calculatePetVal(p, 'value');
                catValues[cKey] = (catValues[cKey] || 0) + v;
            });
            const totalVal = Object.values(catValues).reduce((a,b)=>a+b,0);
            const rColors = { 'Legendary':'#ff9800','Ultra-Rare':'#f06292','Rare':'#4fc3f7','Uncommon':'#81c784','Common':'#bdbdbd' };
            const cColors = { 'High Tier':'#a855f7','Preppy':'#ec4899','Exotic':'#06b6d4','Classy':'#f59e0b','Randoms':'#64748b' };
            const makeLegend = (data, colorMap) => Object.entries(data).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`<div class="legend-row"><div class="legend-dot" style="background:${colorMap[k]||'#6366f1'}"></div>${k}: <strong>${v}</strong></div>`).join('');
            const makeValLegend = (data, colorMap) => Object.entries(data).sort((a,b)=>b[1]-a[1]).map(([k,v])=>`<div class="legend-row"><div class="legend-dot" style="background:${colorMap[k]||'#6366f1'}"></div>${k}: <strong>${v.toFixed(1)}</strong> (${((v/totalVal)*100).toFixed(0)}%)</div>`).join('');
            body.innerHTML = `
            <div class="analytics-pie-row">
                <div class="analytics-pie-card"><h4>By Rarity (count)</h4><canvas id="rarityPie" width="200" height="200"></canvas><div class="analytics-pie-legend">${makeLegend(rarities,rColors)}</div></div>
                <div class="analytics-pie-card"><h4>By Category (count)</h4><canvas id="catPie" width="200" height="200"></canvas><div class="analytics-pie-legend">${makeLegend(categories,cColors)}</div></div>
                <div class="analytics-pie-card"><h4>Value by Category</h4><canvas id="valPie" width="200" height="200"></canvas><div class="analytics-pie-legend">${makeValLegend(catValues,cColors)}</div></div>
            </div>`;
            if(rarityChartInst) rarityChartInst.destroy();
            if(catChartInst) catChartInst.destroy();
            const makeChart = (id, data, colors) => {
                const sorted = Object.entries(data).sort((a,b)=>b[1]-a[1]);
                return new Chart(document.getElementById(id).getContext('2d'), {
                    type:'doughnut',
                    data:{
                        labels: sorted.map(([k])=>k),
                        datasets:[{ data: sorted.map(([,v])=>v), backgroundColor: sorted.map(([k])=>colors[k]||'#6366f1'), borderColor:'#1a2333', borderWidth:3, hoverOffset:8 }]
                    },
                    options:{ responsive:false, plugins:{ legend:{display:false}, tooltip:{callbacks:{label:ctx=>`${ctx.label}: ${ctx.parsed} (${((ctx.parsed/Object.values(data).reduce((a,b)=>a+b,0))*100).toFixed(1)}%)`}} }, cutout:'62%', animation:{animateScale:true} }
                });
            };
            rarityChartInst = makeChart('rarityPie', rarities, rColors);
            catChartInst = makeChart('catPie', categories, cColors);
            makeChart('valPie', catValues, cColors);
        }

        function closeAnalytics() { document.getElementById('analyticsOverlay').style.display = 'none'; }
        function openHistory() { document.getElementById('historyOverlay').style.display = 'flex'; renderHistoryLog(); }
        function closeHistory() { document.getElementById('historyOverlay').style.display = 'none'; }
        
        function logCurrentTrade() {
            if (state.A.length === 0 && state.B.length === 0) return;
            if (tradeLog.length >= 10) tradeLog.shift();
            const snapshot = {
                timestamp: new Date().toLocaleTimeString(),
                A: JSON.parse(JSON.stringify(state.A)),
                B: JSON.parse(JSON.stringify(state.B)),
                verdict: document.getElementById('verdict').innerText
            };
            tradeLog.push(snapshot);
            alert("Trade Saved to History!");
        }

        function restoreFromLog(index) {
            const entry = tradeLog[index];
            if (!entry) return;
            state.A = JSON.parse(JSON.stringify(entry.A));
            state.B = JSON.parse(JSON.stringify(entry.B));
            closeHistory();
            render();
            playSfx('pop');
        }

        function renderHistoryLog() {
            const list = document.getElementById('historyList');
            if (tradeLog.length === 0) {
                list.innerHTML = '<div style="text-align: center; color: var(--subtext);">No history yet. Calculate trades to save them!</div>';
                return;
            }
            list.innerHTML = tradeLog.slice().reverse().map((entry, idx) => {
                const originalIdx = tradeLog.length - 1 - idx;
                return `<div class="history-item" onclick="restoreFromLog(${originalIdx})"><div class="history-time">${entry.timestamp}</div><div class="history-details"><span>${entry.A.length} Items vs ${entry.B.length} Items</span><span style="color: ${entry.verdict.includes('WIN') ? 'var(--win)' : (entry.verdict.includes('LOSE') ? 'var(--lose)' : 'white')}">${entry.verdict}</span></div></div>`;
            }).join('');
        }

        function calculatePetVal(p, mode) {
            // Always uses value mode - frost values removed
            let val = 0;
            if (p.type === 'neon') {
                if (p.f_st && p.r_st) val = p.nfr_v || p.n_v || p.v;
                else if (p.f_st) val = p.n_f_v || p.n_v || p.v;
                else if (p.r_st) val = p.n_r_v || p.n_v || p.v;
                else val = p.n_v || p.v;
            } else if (p.type === 'mega') {
                if (p.f_st && p.r_st) val = p.mfr_v || p.m_v || p.v;
                else if (p.f_st) val = p.m_f_v || p.m_v || p.v;
                else if (p.r_st) val = p.m_r_v || p.m_v || p.v;
                else val = p.m_v || p.v;
            } else {
                if (p.f_st && p.r_st) val = p.fr_v || p.v;
                else if (p.f_st) val = p.f_v || p.v;
                else if (p.r_st) val = p.r_v || p.v;
                else val = p.v;
            }
            return val || 0;
        }

        function renderInventory() {
            const list = state.inv;
            const grid = document.getElementById('invGrid');
            grid.innerHTML = '';
            let totalV = 0, totalD = 0;
            const groups = {};
            list.forEach(p => {
                const key = `${p.n}|${p.type}|${p.f_st}|${p.r_st}`;
                if (!groups[key]) groups[key] = [];
                groups[key].push(p);
                totalV += calculatePetVal(p, 'value');
                totalD += p.type === 'neon' ? (p.nd || p.d) : (p.type === 'mega' ? (p.md || p.d) : p.d);
            });
            Object.entries(groups).forEach(([key, stack]) => {
                const p = stack[0], count = stack.length;
                const currentDemand = p.type === 'neon' ? (p.nd || p.d) : (p.type === 'mega' ? (p.md || p.d) : p.d);
                const valTotal = calculatePetVal(p, 'value') * count;
                const stackUidsString = JSON.stringify(stack.map(item => item.uid));
                const rarityColor = getRarityColor(p.cat);
                const demandColor = getDemandColor(currentDemand);
                grid.innerHTML += `
                    <div class="card ${lockedPets.has(p.n) ? 'pet-locked' : ''}" style="border-color: ${lockedPets.has(p.n) ? '#f59e0b' : rarityColor}">
                        ${count > 1 ? `<div class="card-stack-badge">x${count}</div>` : ''}
                        <div class="del" onclick="removeStack('inv', ${stackUidsString})">‚úï</div>
                        <div style="position: absolute; top: 5px; right: 28px; background: var(--panel); border-radius: 5px; padding: 2px 4px; font-size: 10px; cursor: pointer; border: 1px solid var(--border); z-index: 12;" onclick="findSimilarToPet(${valTotal})">üîç</div>
                        <button class="lock-btn ${lockedPets.has(p.n) ? 'locked' : ''}" onclick="toggleLockPet('${p.n.replace(/'/g,"\'")}')" title="${lockedPets.has(p.n) ? 'Unlock from AI' : 'Lock from AI'}">${lockedPets.has(p.n) ? 'üîí' : 'üîì'}</button>
                        <div class="card-img-container" 
                             oncontextmenu="handlePetContext(event, ${JSON.stringify(p).replace(/"/g, '&quot;')})"
                             ondblclick="duplicate('inv', ${p.uid})" title="Right click for Qty | Shift + Right click for Graph">
                             <img src="https://amvgg.com/items/${encodeURIComponent(p.n)}.webp">
                        </div>
                        <div class="card-name">${p.n}${getTrendIcons(p)}</div>
                        <div class="card-val">${valTotal.toFixed(2)}</div>
                        <div class="card-demand" style="color: ${demandColor}">Dem: ${currentDemand}</div>
                        <div class="toggles">
                            <div class="t-btn ${p.type==='neon'?'active':''}" onclick="togStack('inv',${stackUidsString},'n')">N</div>
                            <div class="t-btn ${p.type==='mega'?'active':''}" onclick="togStack('inv',${stackUidsString},'m')">M</div>
                            <div class="t-btn ${p.f_st?'active':''}" onclick="togStack('inv',${stackUidsString},'f')">F</div>
                            <div class="t-btn ${p.r_st?'active':''}" onclick="togStack('inv',${stackUidsString},'r')">R</div>
                        </div>
                    </div>`;
            });
            const finalVal = totalV.toFixed(2);
            document.getElementById('invTotalValue').innerText = finalVal;
            document.getElementById('invAvgDemand').innerText = list.length > 0 ? (totalD / list.length).toFixed(1) : "0.0";
            const v = parseFloat(finalVal);
            document.getElementById('mile-1').classList.toggle('active', v >= 1);
            document.getElementById('mile-2').classList.toggle('active', v >= 10);
            document.getElementById('mile-3').classList.toggle('active', v >= 50);
            document.getElementById('mile-4').classList.toggle('active', v >= 100);
            document.getElementById('mile-5').classList.toggle('active', v >= 155);
            updateAISuggestions(list);
        }

        function removeStack(s, uids) { pushState(); state[s] = state[s].filter(x => x.uid !== uids[0]); renderInventory(); saveTrade(); }
        function togStack(s, uids, type) {
            pushState(); uids.forEach(uid => {
                const p = state[s].find(x => x.uid === uid);
                if (!p) return;
                if (type === 'n') p.type = p.type === 'neon' ? 'reg' : 'neon';
                else if (type === 'm') p.type = p.type === 'mega' ? 'reg' : 'mega';
                else if (type === 'f') p.f_st = !p.f_st;
                else if (type === 'r') p.r_st = !p.r_st;
            });
            saveTrade(); renderInventory();
        }

        function findSimilarToTotal() { const totalVal = parseFloat(document.getElementById('invTotalValue').innerText); showSimilarPopup(totalVal); }
        function findSimilarToPet(val) { showSimilarPopup(val); }
        function showSimilarPopup(val) {
            const overlay = document.getElementById('similarOverlay');
            const list = document.getElementById('similarList');
            overlay.style.display = 'flex';
            const matches = ALL_PETS.filter(p => p.v >= val * 0.90 && p.v <= val * 1.15).sort((a, b) => b.d - a.d).slice(0, 30);
            list.innerHTML = matches.map(p => {
                const isSelected = state.aiTargetPets.some(x => x.n === p.n);
                return `<div class="similar-item ${isSelected ? 'selected' : ''}" onclick="toggleAiTarget(this, '${p.n.replace(/'/g, "\\'")}')"><img src="https://amvgg.com/items/${encodeURIComponent(p.n)}.webp" style="width: 40px; height: 40px; object-fit: contain;"><div style="flex: 1;"><div style="font-weight: 800; font-size: 0.9em;">${p.n}</div><div style="font-size: 0.7em; color: var(--subtext);">Value: ${p.v.toFixed(2)} | Demand: ${p.d}</div></div><input type="checkbox" ${isSelected ? 'checked' : ''} style="pointer-events: none;"></div>`;
            }).join('');
        }
        function toggleAiTarget(element, name) {
            const pet = ALL_PETS.find(x => x.n === name);
            const index = state.aiTargetPets.findIndex(x => x.n === name);
            if (index > -1) state.aiTargetPets.splice(index, 1);
            else state.aiTargetPets.push(pet);
            element.classList.toggle('selected');
            element.querySelector('input').checked = !element.querySelector('input').checked;
        }
        function closeSimilarPopup() { document.getElementById('similarOverlay').style.display = 'none'; renderInventory(); }

        function setAiStrategy(mode) {
            state.aiMode = mode;
            state.aiTargetPets = []; 
            document.getElementById('aiTogNormal').classList.toggle('active', mode === 'normal');
            document.getElementById('aiTogVelocity').classList.toggle('active', mode === 'velocity');
            renderInventory();
        }

        function updateStrategyCount(val) {
            state.strategyLimit = parseInt(val);
            document.getElementById('strategyCountVal').innerText = val;
            renderInventory();
        }

        function clearDreamPet() { state.dreamPet = null; renderInventory(); }

        // ================================================================
        // PET INTELLIGENCE DATABASE
        // Only HTT (Hard To Trade) list is hardcoded here.
        // Everything else (preppy, high tier, exotic) is read
        // dynamically from the pet's cat field.
        // ================================================================
        const HTT_PETS = new Set([
            // Lunar / Ox category - consistently HTT across all sources
            'Metal Ox','Lunar Ox','Musk Ox','Ox',
            // Minion / Zodiac - bottom of desirability
            'Zodiac Minion Chick','Minion Chick',
            // Gorillas - fairground pets, chef/karate especially inflated
            'Chef Gorilla','Karate Gorilla','Drill Gorilla',
            'Gorilla','Capuchin Monkey','Gibbon',
            // Lunar Tigers - very low demand
            'Luna Tiger','Lunar Tiger','Lunar Snow Leopard','Luna Moonbear',
            // Golden/Diamond grind pets - overpopulated, low real demand
            'Golden Dragon','Diamond Dragon',
            'Golden Griffin','Diamond Griffin',
            'Golden Unicorn','Diamond Unicorn',
            'Golden Ladybug','Diamond Ladybug',
            'Golden Taurus Beetle',
            // Shop/Robux pets that everyone has
            'Kitsune','Robo Dog','Cerberus','Capricorn',
            // Old pets with ugly/boring designs
            'Wild Boar','Camel','Donkey','Stegosaurus',
            'Musk Ox','Phou Deer',
            // Other commonly cited HTT
            'Chimera','Red Dragon','Mummy Cat',
            'White Mummy Cat','Black Mummy Cat',
            'Persian Cat','Dracula Parrot',
            'Toy Monkey','Albino Monkey',
            'Ancient Dragon','Guardian Lion',
            'Baku','Axolotl','Weevil',
            'Griffin','Snow Owl',
            'T-Rex'
        ]);

        function isHTT(name) {
            return HTT_PETS.has(name);
        }

        // O(1) lookup ‚Äî cache is built once when history loads
        function getManipulationFlag(petName) {
            return manipCache.get((petName || '').toLowerCase().trim()) || null;
        }

        // Tier ladder for trade-up advice
        const TIER_LADDER = [
            { name: 'Starter', min: 0,    max: 2,    next: 'Commons/Uncommons' },
            { name: 'Commons', min: 2,    max: 8,    next: 'Mid-Rares (Frost Fury, Crow level)' },
            { name: 'Mid-Tier', min: 8,   max: 25,   next: 'High-Tier (Owl, Turtle, Kangaroo level)' },
            { name: 'High-Tier', min: 25, max: 60,   next: 'Premium (Crow, Parrot, Hedgehog level)' },
            { name: 'Premium',  min: 60,  max: 130,  next: 'Top-Tier (Frost Dragon, Owl, Parrot level)' },
            { name: 'Top-Tier', min: 130, max: 300,  next: 'Exotic (Giraffe, Bat Dragon level)' },
            { name: 'Exotic',   min: 300, max: 99999, next: 'you are at the top tier' }
        ];

        function getTierInfo(val) {
            return TIER_LADDER.find(t => val >= t.min && val < t.max) || TIER_LADDER[0];
        }

        function getPetDemandTier(p) {
            const d = p.type === 'neon' ? (p.nd || p.d) : (p.type === 'mega' ? (p.md || p.d) : p.d);
            if (d >= 7) return 'high';
            if (d >= 4) return 'mid';
            return 'low';
        }

        function getCatLabel(p) {
            const c = (p.cat || '').toLowerCase();
            if (c.includes('high tier')) return 'High Tier';
            if (c.includes('preppy')) return 'Preppy';
            if (c.includes('exotic')) return 'Exotic';
            if (c.includes('classy')) return 'Classy';
            if (c.includes('mid tier')) return 'Mid Tier';
            return 'Randoms';
        }

        // Numerical prestige tier for category comparisons
        // Higher = more desirable / harder to replace
        function getCatTier(p) {
            const c = getCatLabel(p);
            if (c === 'Exotic')   return 5;
            if (c === 'High Tier') return 4;
            if (c === 'Preppy')   return 3;
            if (c === 'Classy')   return 2;
            if (c === 'Mid Tier') return 1.5;
            return 1; // Randoms
        }

        // Best prestige tier across a bundle of pets
        function getBundleTier(bundle) {
            return bundle.reduce((best, p) => Math.max(best, getCatTier(p)), 1);
        }

        // Effective demand of a pet accounting for neon/mega demand fields
        function getEffDemand(p) {
            return p.type === 'neon' ? (p.nd || p.d) : p.type === 'mega' ? (p.md || p.d) : p.d;
        }


        function getPetLabel(p) {
            // Returns a human-readable label like "NFR Crow", "Neon Bat Dragon", "FR Turtle"
            let prefix = '';
            if (p.type === 'mega') {
                prefix = (p.f_st && p.r_st) ? 'MFR ' : (p.f_st ? 'MF ' : (p.r_st ? 'MR ' : 'Mega '));
            } else if (p.type === 'neon') {
                prefix = (p.f_st && p.r_st) ? 'NFR ' : (p.f_st ? 'NF ' : (p.r_st ? 'NR ' : 'Neon '));
            } else {
                prefix = (p.f_st && p.r_st) ? 'FR ' : (p.f_st ? 'F ' : (p.r_st ? 'R ' : ''));
            }
            return prefix + p.n;
        }

        // Score a potential target (0-10). offerBundle = array of pets you're giving.
        // This gives the scorer full context of what's being offered, not just value.
        // ================================================================
        // üß† AI INTELLIGENCE ENGINE v2 ‚Äî Complete Rewrite
        // ================================================================

        // ‚îÄ‚îÄ DYNAMIC HTT DETECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Hardcoded seed list (always HTT regardless of data)
        const HTT_SEED = new Set([
            'Metal Ox','Lunar Ox','Musk Ox','Ox',
            'Zodiac Minion Chick','Minion Chick',
            'Chef Gorilla','Karate Gorilla','Drill Gorilla','Gorilla','Capuchin Monkey','Gibbon',
            'Luna Tiger','Lunar Tiger','Lunar Snow Leopard','Luna Moonbear',
            'Golden Dragon','Diamond Dragon','Golden Griffin','Diamond Griffin',
            'Golden Unicorn','Diamond Unicorn','Golden Ladybug','Diamond Ladybug','Golden Taurus Beetle',
            'Kitsune','Robo Dog','Cerberus','Capricorn',
            'Wild Boar','Camel','Donkey','Stegosaurus','Phou Deer',
            'Chimera','Red Dragon','Mummy Cat','White Mummy Cat','Black Mummy Cat',
            'Persian Cat','Dracula Parrot','Toy Monkey','Albino Monkey',
            'Ancient Dragon','Guardian Lion','Baku','Axolotl','Weevil','Griffin','Snow Owl','T-Rex'
        ]);

        // Dynamic HTT cache ‚Äî built from live data after pets load
        const dynamicHTT = new Set();
        function buildDynamicHTT() {
            dynamicHTT.clear();
            ALL_PETS.forEach(p => {
                // Any pet with demand ‚â§ 2 AND no uptrend AND value ‚â• 1 = likely HTT
                const isSeed = HTT_SEED.has(p.n);
                const lowDem  = parseFloat(p.d) <= 2;
                const falling = (p.dt || '').includes('‚ùÑÔ∏è') || (p.vt || '').includes('üìâ');
                const notRising = !(p.vt || '').includes('üìà') && !(p.dt || '').includes('üî•');
                const hasValue  = parseFloat(p.v) >= 1;
                if (isSeed || (lowDem && falling && hasValue)) dynamicHTT.add(p.n);
            });
        }
        function isHTT(name) { return dynamicHTT.has(name) || HTT_SEED.has(name); }

        // ‚îÄ‚îÄ TRADE FREQUENCY INDEX ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Built from HISTORY_DATA once it loads ‚Äî how often each pet appears in trades
        const tradeFreqMap = new Map(); // petName.lower ‚Üí count per day
        function buildTradeFreqMap() {
            tradeFreqMap.clear();
            if (!HISTORY_DATA || HISTORY_DATA.length === 0) return;
            const countMap = new Map();
            let minTime = Infinity, maxTime = -Infinity;
            HISTORY_DATA.forEach(row => {
                const name = (row.name || row['pet name'] || '').toLowerCase().trim();
                if (!name) return;
                countMap.set(name, (countMap.get(name) || 0) + 1);
                const t = new Date(row.timestamp || row.time || '');
                if (!isNaN(t)) { minTime = Math.min(minTime, t); maxTime = Math.max(maxTime, t); }
            });
            const daySpan = Math.max(1, (maxTime - minTime) / 86400000);
            countMap.forEach((count, name) => {
                tradeFreqMap.set(name, count / daySpan);
            });
        }
        function getTradeFreq(name) {
            return tradeFreqMap.get((name || '').toLowerCase().trim()) || 0;
        }
        // Normalised 0‚Äì1 liquidity score (higher = trades more often)
        function getLiquidityScore(name) {
            const freq = getTradeFreq(name);
            const maxFreq = 5; // cap at 5 trades/day = max liquidity
            return Math.min(1, freq / maxFreq);
        }

        // ‚îÄ‚îÄ TREND VELOCITY ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Instead of just emoji flags, calculate actual rate of value change
        function getTrendVelocity(petName) {
            const records = HISTORY_DATA.filter(r =>
                (r.name || r['pet name'] || '').toLowerCase().trim() === (petName || '').toLowerCase().trim()
            );
            if (records.length < 3) return { pctChange: 0, direction: 'stable', acceleration: 0 };
            const vals = records.map(r => parseFloat(r.v) || 0).filter(v => v > 0);
            if (vals.length < 3) return { pctChange: 0, direction: 'stable', acceleration: 0 };
            // Recent 40% vs earlier 40%
            const recentSlice  = vals.slice(Math.floor(vals.length * 0.6));
            const earlierSlice = vals.slice(0, Math.floor(vals.length * 0.4));
            const recentAvg  = recentSlice.reduce((a,b)=>a+b,0)  / recentSlice.length;
            const earlierAvg = earlierSlice.reduce((a,b)=>a+b,0) / earlierSlice.length;
            const pctChange  = earlierAvg > 0 ? ((recentAvg - earlierAvg) / earlierAvg) * 100 : 0;
            // Acceleration: compare first half vs second half of recent slice
            const mid = Math.floor(recentSlice.length / 2);
            const firstHalf  = recentSlice.slice(0, mid);
            const secondHalf = recentSlice.slice(mid);
            const fAvg = firstHalf.length  > 0 ? firstHalf.reduce((a,b)=>a+b,0)  / firstHalf.length  : recentAvg;
            const sAvg = secondHalf.length > 0 ? secondHalf.reduce((a,b)=>a+b,0) / secondHalf.length : recentAvg;
            const acceleration = fAvg > 0 ? ((sAvg - fAvg) / fAvg) * 100 : 0;
            return {
                pctChange,
                acceleration,
                direction: pctChange > 5 ? 'rising' : pctChange < -5 ? 'falling' : 'stable'
            };
        }

        // Quick cached version ‚Äî computed once per session
        const trendVelocityCache = new Map();
        function getCachedTrend(name) {
            const key = (name || '').toLowerCase().trim();
            if (!trendVelocityCache.has(key)) {
                trendVelocityCache.set(key, getTrendVelocity(name));
            }
            return trendVelocityCache.get(key);
        }

        // ‚îÄ‚îÄ ACCEPTANCE PROBABILITY MODEL ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Estimates % chance a target owner actually accepts your offer
        function getAcceptanceProbability(offerVal, offerAvgDemand, target, offerBundle) {
            const targetVal = calculatePetVal({...target, type:'reg', f_st:false, r_st:false}, 'value');
            const valGapPct = targetVal > 0 ? ((offerVal - targetVal) / targetVal) * 100 : 0;
            // Base: how much you're overpaying
            let prob = 50;
            if      (valGapPct >= 20) prob = 85;
            else if (valGapPct >= 10) prob = 73;
            else if (valGapPct >= 5)  prob = 63;
            else if (valGapPct >= 0)  prob = 52;
            else if (valGapPct >= -5) prob = 38;
            else if (valGapPct >= -10)prob = 25;
            else                      prob = 12;
            // Demand of offer vs target demand
            if (offerAvgDemand >= 7 && target.d < 5) prob -= 15; // they don't want your pets either
            if (offerAvgDemand >= target.d)           prob += 5;  // your pets are as liquid as theirs
            // HTT in offer = they might not want it
            const offerHTT = offerBundle && offerBundle.some(p => isHTT(p.n));
            if (offerHTT) prob -= 12;
            // Many pets in offer = friction
            const bundleSize = offerBundle ? offerBundle.length : 1;
            if (bundleSize >= 5) prob -= 15;
            else if (bundleSize >= 4) prob -= 8;
            else if (bundleSize >= 3) prob -= 3;
            // Category desirability of offer
            const offerTier = offerBundle ? getBundleTier(offerBundle) : 1;
            if (offerTier >= 4) prob += 8;  // Exotic/High Tier offer = people want it
            else if (offerTier >= 3) prob += 4;
            // Manipulation spike on target = they might be holding hoping for more
            if (getManipulationFlag(target.n)) prob -= 8;
            // Trend double-win: offering falling for rising = great deal but they know it too
            const offerTrend = offerBundle ? offerBundle.reduce((s,p) => {
                const t = getCachedTrend(p.n);
                return s + (t.direction === 'rising' ? 1 : t.direction === 'falling' ? -1 : 0);
            }, 0) / Math.max(1, offerBundle.length) : 0;
            const targetTrend = getCachedTrend(target.n);
            if (offerTrend > 0 && targetTrend.direction === 'falling') prob += 10; // you're giving rising, they're giving falling
            if (offerTrend < 0 && targetTrend.direction === 'rising')  prob -= 10;
            return Math.max(5, Math.min(95, Math.round(prob)));
        }

        // ‚îÄ‚îÄ INVENTORY HEALTH SCORE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function getInventoryHealthReport(inventory) {
            if (!inventory || inventory.length === 0) return null;
            let score = 0;
            const breakdown = [];

            const avgDemand = inventory.reduce((s,p) => s + (parseFloat(getEffDemand(p)) || 0), 0) / inventory.length;
            const avgVal    = inventory.reduce((s,p) => s + calculatePetVal(p,'value'), 0) / inventory.length;
            const httCount  = inventory.filter(p => isHTT(p.n)).length;
            const httPct    = httCount / inventory.length;
            const manipCount = inventory.filter(p => getManipulationFlag(p.n)).length;
            const fallingCount = inventory.filter(p => (p.dt||'').includes('‚ùÑÔ∏è') || (p.vt||'').includes('üìâ')).length;
            const risingCount  = inventory.filter(p => (p.vt||'').includes('üìà') || (p.dt||'').includes('üî•')).length;
            const catDist = {};
            inventory.forEach(p => { const c = getCatLabel(p); catDist[c] = (catDist[c]||0)+1; });
            const premiumPct = ((catDist['Exotic']||0) + (catDist['High Tier']||0) + (catDist['Preppy']||0)) / inventory.length;
            const avgLiq = inventory.reduce((s,p) => s + getLiquidityScore(p.n), 0) / inventory.length;

            // Demand component (0-30)
            const demScore = Math.min(30, Math.round((avgDemand / 10) * 30));
            score += demScore;
            breakdown.push({ label: 'Demand Quality', score: demScore, max: 30,
                tip: avgDemand >= 7 ? 'Excellent demand across inventory' :
                     avgDemand >= 5 ? 'Good demand, room to improve' :
                     avgDemand >= 3 ? 'Moderate demand ‚Äî target pets with 6+ demand' :
                     'Low demand ‚Äî your pets are hard to trade. Prioritize demand upgrades.' });

            // Liquidity component (0-20)
            const liqScore = Math.min(20, Math.round(avgLiq * 20));
            score += liqScore;
            breakdown.push({ label: 'Market Liquidity', score: liqScore, max: 20,
                tip: avgLiq >= 0.7 ? 'Your pets trade frequently ‚Äî high liquidity' :
                     avgLiq >= 0.4 ? 'Decent liquidity' :
                     'Low liquidity ‚Äî your pets don\'t trade often. Consider swapping to more popular pets.' });

            // Category component (0-20)
            const catScore = Math.min(20, Math.round(premiumPct * 20));
            score += catScore;
            breakdown.push({ label: 'Category Quality', score: catScore, max: 20,
                tip: premiumPct >= 0.5 ? 'Strong Exotic/High Tier/Preppy presence' :
                     premiumPct >= 0.25 ? 'Some premium category pets' :
                     'Mostly Randoms/Mid Tier. Adding Preppy or High Tier pets will help significantly.' });

            // Trend health component (0-15)
            const trendScore = Math.max(0, Math.min(15, Math.round(((risingCount - fallingCount * 1.5) / inventory.length) * 15 + 7)));
            score += trendScore;
            breakdown.push({ label: 'Trend Health', score: trendScore, max: 15,
                tip: risingCount > fallingCount ? `${risingCount} pets trending up ‚Äî good momentum` :
                     fallingCount > risingCount  ? `${fallingCount} pets trending down ‚Äî consider offloading` :
                     'Mixed trends ‚Äî monitor closely' });

            // HTT penalty (0-15)
            const httScore = Math.max(0, Math.round((1 - httPct * 2) * 15));
            score += httScore;
            breakdown.push({ label: 'Tradability', score: httScore, max: 15,
                tip: httCount === 0 ? 'No HTT pets ‚Äî clean inventory' :
                     httCount <= 1  ? `${httCount} HTT pet detected` :
                     `${httCount} HTT pets dragging down tradability. These are hard to move.` });

            // Manipulation risk (bonus/penalty out of 10, included in total but not shown separately)
            if (manipCount > 0) score = Math.max(0, score - manipCount * 5);

            const grade = score >= 85 ? 'S' : score >= 70 ? 'A' : score >= 55 ? 'B' : score >= 40 ? 'C' : score >= 25 ? 'D' : 'F';
            const gradeColor = score >= 85 ? '#a855f7' : score >= 70 ? '#34d399' : score >= 55 ? '#fbbf24' : score >= 40 ? '#fb923c' : '#f87171';

            const advice = [];
            if (avgDemand < 5) advice.push('üéØ Priority: Trade into pets with demand 6+');
            if (httCount > 0)  advice.push(`‚ö†Ô∏è Offload ${httCount} HTT pet${httCount>1?'s':''} as soon as possible`);
            if (manipCount > 0)advice.push(`üìä ${manipCount} pet${manipCount>1?'s are':' is'} flagged as potentially manipulated`);
            if (fallingCount > risingCount) advice.push('üìâ More falling than rising pets ‚Äî consider rotating inventory');
            if (premiumPct < 0.2 && avgVal >= 10) advice.push('üí° Consider trading into Preppy or High Tier pets for better resale');
            if (advice.length === 0) advice.push('‚úÖ Inventory looks healthy ‚Äî focus on tier progression');

            return { score: Math.min(100, score), grade, gradeColor, breakdown, advice, avgDemand, premiumPct, httCount, risingCount, fallingCount };
        }

        // ‚îÄ‚îÄ CHAIN TRADE ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Finds a 2-step path: inventory ‚Üí bridge ‚Üí target
        // Returns best chain trade suggestion if direct path doesn't exist
        function findChainTrade(inventory, targetVal, targetDem, targetCat) {
            if (!inventory || inventory.length === 0) return null;
            const invVal = inventory.reduce((s,p) => s + calculatePetVal(p,'value'), 0);
            // Only suggest chain trade if direct path seems hard
            // Look for a "bridge" pet: demand 7+, value in range, that is commonly traded
            const bridgeCandidates = ALL_PETS.filter(b => {
                const bv = calculatePetVal({...b,type:'reg',f_st:false,r_st:false},'value');
                return b.d >= 6
                    && bv >= invVal * 0.85 && bv <= invVal * 1.20
                    && getLiquidityScore(b.n) >= 0.3
                    && !isHTT(b.n);
            }).sort((a,b) => b.d - a.d).slice(0, 5);

            for (const bridge of bridgeCandidates) {
                const bv = calculatePetVal({...bridge,type:'reg',f_st:false,r_st:false},'value');
                // Can we then get the target type from bridge?
                const step2 = ALL_PETS.filter(t => {
                    const tv = calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value');
                    return tv >= targetVal * 0.90 && tv <= targetVal * 1.25
                        && t.d >= targetDem - 1
                        && getCatLabel(t) === targetCat;
                }).slice(0,1)[0];
                if (step2 && step2.n !== bridge.n) {
                    return { bridge, step2, bridgeVal: bv };
                }
            }
            return null;
        }

        // ‚îÄ‚îÄ WHAT SHOULD I TARGET NEXT ENGINE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Proactively recommends the best pets to target in your value range
        function getProactiveTargets(totalInvVal, limit = 6) {
            if (!ALL_PETS || ALL_PETS.length === 0) return [];
            const minVal = totalInvVal * 0.70;
            const maxVal = totalInvVal * 1.35;
            return ALL_PETS
                .filter(p => {
                    const v = calculatePetVal({...p,type:'reg',f_st:false,r_st:false},'value');
                    return v >= minVal && v <= maxVal && !isHTT(p.n) && !getManipulationFlag(p.n);
                })
                .map(p => {
                    const trend = getCachedTrend(p.n);
                    const liq   = getLiquidityScore(p.n);
                    const catT  = getCatTier(p);
                    let score = 0;
                    score += (parseFloat(p.d) || 0) * 3;          // demand matters most
                    score += liq * 20;                              // liquidity
                    score += catT * 4;                              // category
                    score += trend.pctChange * 0.5;                // rising trend bonus
                    score += (trend.acceleration > 0 ? trend.acceleration * 0.3 : 0); // accelerating bonus
                    if ((p.vt||'').includes('üìà')) score += 5;
                    if ((p.dt||'').includes('üî•')) score += 5;
                    if ((p.vt||'').includes('üìâ')) score -= 8;
                    if ((p.dt||'').includes('‚ùÑÔ∏è')) score -= 8;
                    return { p, score, trend, liq };
                })
                .sort((a,b) => b.score - a.score)
                .slice(0, limit);
        }

        // ‚îÄ‚îÄ OVERPAY PSYCHOLOGY FACTOR ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Returns a multiplier for how much people typically overpay for this category
        function getOverpayFactor(pet) {
            const cat = getCatLabel(pet);
            // Preppy: community overpays 10-20% emotionally
            if (cat === 'Preppy') return 1.15;
            // Exotic: niche demand, people pay premium
            if (cat === 'Exotic') return 1.10;
            // High Tier: liquid, slight premium
            if (cat === 'High Tier') return 1.06;
            // Classy: slight premium
            if (cat === 'Classy') return 1.03;
            // Randoms: need to offer MORE than value
            return 0.95;
        }

        // ‚îÄ‚îÄ BUNDLE READABILITY SCORE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // A "readable" bundle is one people can quickly understand and trust
        function getBundleReadabilityScore(bundle) {
            if (!bundle || bundle.length === 0) return 10;
            let score = 10;
            // Too many pets = hard to evaluate
            if (bundle.length >= 5) score -= 4;
            else if (bundle.length >= 4) score -= 2;
            else if (bundle.length >= 3) score -= 1;
            // All randoms = untrustworthy
            const randCount = bundle.filter(p => getCatLabel(p) === 'Randoms').length;
            score -= randCount * 0.8;
            // Mixed categories = confusing
            const uniqueCats = new Set(bundle.map(p => getCatLabel(p))).size;
            if (uniqueCats >= 4) score -= 2;
            // HTT in bundle = major red flag
            const httCount = bundle.filter(p => isHTT(p.n)).length;
            score -= httCount * 3;
            // 1 clean high-tier anchor = great
            const hasAnchor = bundle.some(p => getCatTier(p) >= 3);
            if (hasAnchor && bundle.length <= 3) score += 2;
            return Math.max(0, Math.min(10, score));
        }

        // ‚îÄ‚îÄ MAIN SCORING FUNCTION (v2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        // Fully contextual, multiplicative, psychology-aware
        function scorePotentialTarget(target, offerVal, offerAvgDemand, offerBundle) {
            const targetVal    = calculatePetVal({...target, type:'reg', f_st:false, r_st:false}, 'value');
            const targetDemand = parseFloat(target.d) || 0;
            const targetCat    = getCatLabel(target);
            const targetTier   = getCatTier(target);
            const offerTier    = offerBundle ? getBundleTier(offerBundle) : 1;
            const offerDemTier = offerAvgDemand >= 7 ? 'high' : offerAvgDemand >= 4 ? 'mid' : 'low';
            const targetDemTier = getPetDemandTier(target);

            // ‚îÄ‚îÄ Value alignment (contextual ‚Äî gap tolerance scales with value) ‚îÄ‚îÄ
            // At low values a 15% gap is nothing; at high values it's huge
            const valGap = (targetVal - offerVal) / Math.max(offerVal, 0.01);
            const valueTolerance = offerVal >= 200 ? 0.08 : offerVal >= 50 ? 0.12 : 0.18;
            let valueScore;
            if      (valGap > valueTolerance && valGap <= 0.30) valueScore = 2.5;   // ideal gain
            else if (valGap >= 0 && valGap <= valueTolerance)   valueScore = 1.8;   // fair
            else if (valGap > 0.30)                              valueScore = 1.2;   // big gain (hard to get)
            else if (valGap >= -0.05)                            valueScore = 0.5;   // tiny loss
            else if (valGap >= -0.12)                            valueScore = -1.0;  // notable loss
            else                                                 valueScore = -4.0;  // big loss

            // ‚îÄ‚îÄ Demand score (non-linear ‚Äî demand 9 >> demand 8) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const demandScore = targetDemand >= 9 ? 4 : targetDemand >= 7.5 ? 3 : targetDemand >= 6 ? 2 :
                                targetDemand >= 4 ? 1 : targetDemand >= 3 ? -0.5 : -3;

            // ‚îÄ‚îÄ Demand tier improvement multiplier ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let demTierMult = 1.0;
            if (offerDemTier === 'low'  && targetDemTier === 'high') demTierMult = 1.5;
            else if (offerDemTier === 'low'  && targetDemTier === 'mid')  demTierMult = 1.2;
            else if (offerDemTier === 'mid'  && targetDemTier === 'high') demTierMult = 1.2;
            else if (offerDemTier === 'high' && targetDemTier === 'low')  demTierMult = 0.4;
            else if (offerDemTier === 'high' && targetDemTier === 'mid')  demTierMult = 0.8;
            else if (targetDemTier === 'low') demTierMult = 0.6;

            // ‚îÄ‚îÄ Category score ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const catScore = targetCat === 'Exotic' ? 2.5 : targetCat === 'High Tier' ? 2.2 :
                             targetCat === 'Preppy' ? 2.0 : targetCat === 'Classy' ? 1.0 :
                             targetCat === 'Mid Tier' ? 0.5 : -0.5;

            // ‚îÄ‚îÄ Category downgrade protection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const catDrop = offerTier - targetTier;
            const catDropPenalty = catDrop >= 3 ? -5 : catDrop >= 2 ? -3 : catDrop >= 1 ? -1 :
                                   catDrop <= -1 ? 0.8 : 0;

            // ‚îÄ‚îÄ Overpay psychology factor ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            // If they're giving a Preppy pet, the effective value is higher than listed
            const offerPsych  = offerBundle ? offerBundle.reduce((s,p) => s + getOverpayFactor(p), 0) / offerBundle.length : 1;
            const targetPsych = getOverpayFactor(target);
            const psychBonus  = (targetPsych - offerPsych) * 3; // positive if target has higher overpay factor

            // ‚îÄ‚îÄ Trend velocity (double-win / double-loss detection) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const targetTrend = getCachedTrend(target.n);
            const offerTrendScore = offerBundle ? offerBundle.reduce((s,p) => {
                const t = getCachedTrend(p.n);
                return s + (t.direction === 'rising' ? 1 : t.direction === 'falling' ? -1 : 0);
            }, 0) / Math.max(1, offerBundle.length) : 0;

            let trendBonus = 0;
            if (targetTrend.direction === 'rising'  && offerTrendScore < 0)  trendBonus += 2;  // DOUBLE WIN
            else if (targetTrend.direction === 'rising')                       trendBonus += 0.8;
            else if (targetTrend.direction === 'falling' && offerTrendScore > 0) trendBonus -= 2; // DOUBLE LOSS
            else if (targetTrend.direction === 'falling')                      trendBonus -= 1.2;
            // Acceleration bonus
            if (targetTrend.acceleration > 10) trendBonus += 0.5;

            // ‚îÄ‚îÄ Liquidity & trade frequency ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const liq = getLiquidityScore(target.n);
            const liqBonus = (liq - 0.3) * 2; // neutral at 0.3, max +1.4, min -0.6

            // ‚îÄ‚îÄ Bundle readability (affects acceptance, not value) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const readability = offerBundle ? getBundleReadabilityScore(offerBundle) / 10 : 1;
            const readBonus = (readability - 0.7) * 1.5;

            // ‚îÄ‚îÄ Demand parity protection ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let parityPenalty = 0;
            if (offerAvgDemand >= 7 && targetDemand < 4)  parityPenalty = -4;
            else if (offerAvgDemand >= 5 && targetDemand < 2) parityPenalty = -2;

            // ‚îÄ‚îÄ HTT penalty ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const httPenalty = isHTT(target.n) ? -4 : 0;

            // ‚îÄ‚îÄ Manipulation flag ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const manipPenalty = getManipulationFlag(target.n) ? -2.5 : 0;

            // ‚îÄ‚îÄ Composite score (base 5, multiplicative demand tier) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const rawScore = 5
                + valueScore
                + (demandScore * demTierMult)
                + catScore
                + catDropPenalty
                + psychBonus
                + trendBonus
                + liqBonus
                + readBonus
                + parityPenalty
                + httPenalty
                + manipPenalty;

            return Math.max(0, Math.min(10, parseFloat(rawScore.toFixed(2))));
        }

        // ‚îÄ‚îÄ REASON TEXT v2 ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function buildReasonText(target, offerVal, offerAvgDemand, offerBundle) {
            const catLabel  = getCatLabel(target);
            const targetVal = calculatePetVal({...target,type:'reg',f_st:false,r_st:false},'value');
            const valGapPct = ((targetVal - offerVal) / Math.max(offerVal, 0.01) * 100).toFixed(0);
            const trend     = getCachedTrend(target.n);
            const liq       = getLiquidityScore(target.n);
            const overpay   = getOverpayFactor(target);
            const parts     = [];

            // Demand
            if (target.d >= 9)      parts.push(`üî• exceptional demand (${target.d}) ‚Äî moves instantly`);
            else if (target.d >= 7) parts.push(`‚ö° high demand (${target.d}) ‚Äî gets offers fast`);
            else if (target.d >= 5) parts.push(`moderate demand (${target.d})`);
            else if (target.d >= 3) parts.push(`low demand (${target.d}) ‚Äî may take time`);
            else                    parts.push(`‚ùÑÔ∏è very low demand (${target.d}) ‚Äî could sit for weeks`);

            // Category insight
            if (catLabel === 'Preppy')    parts.push('Preppy ‚Äî community pays emotional premium');
            else if (catLabel === 'High Tier') parts.push('High Tier ‚Äî liquid and always tradeable');
            else if (catLabel === 'Exotic')    parts.push('Exotic ‚Äî niche but strong demand');
            else if (catLabel === 'Classy')    parts.push('Classy ‚Äî decent category');
            else if (catLabel === 'Randoms')   parts.push('Randoms ‚Äî needs significant overpay to move');

            // Trend velocity
            if (trend.direction === 'rising')  parts.push(`üìà rising +${trend.pctChange.toFixed(0)}% recently${trend.acceleration > 5 ? ' (accelerating)' : ''}`);
            else if (trend.direction === 'falling') parts.push(`üìâ falling ${trend.pctChange.toFixed(0)}% recently ‚Äî verify before accepting`);

            // Liquidity
            if (liq >= 0.6)       parts.push('üåä frequently traded');
            else if (liq <= 0.15) parts.push('üßä rarely traded');

            // Overpay psychology
            if (overpay >= 1.12)  parts.push('community often overpays for this type');

            // HTT
            if (isHTT(target.n)) parts.push('‚ö†Ô∏è community-flagged HTT ‚Äî re-trading will be hard');

            // Manipulation
            const manip = getManipulationFlag(target.n);
            if (manip) parts.push(`‚ö†Ô∏è ${manip}`);

            // Value gap
            const vg = parseFloat(valGapPct);
            if (vg > 10)       parts.push(`+${valGapPct}% value gain`);
            else if (vg < -5)  parts.push(`${Math.abs(vg).toFixed(0)}% value loss ‚Äî buying demand/category`);

            // Double win/loss detection
            if (offerBundle) {
                const offerTrend = offerBundle.reduce((s,p) => {
                    const t = getCachedTrend(p.n);
                    return s + (t.direction === 'rising' ? 1 : t.direction === 'falling' ? -1 : 0);
                }, 0);
                if (trend.direction === 'rising' && offerTrend < 0)
                    parts.push('üöÄ DOUBLE WIN: you\'re giving falling pets for a rising one');
                else if (trend.direction === 'falling' && offerTrend > 0)
                    parts.push('‚õî DOUBLE LOSS: giving rising pets for a falling one');
            }

            return parts.join(' ¬∑ ');
        }

        function buildSmartBundle(inventory, targetVal, mode) {
            const maxPets = mode === 'velocity' ? 6 : 4;
            const sorted = [...inventory].sort((a, b) => {
                const dA = getEffDemand(a), dB = getEffDemand(b);
                if (dB !== dA) return dB - dA;
                return calculatePetVal(b, 'value') - calculatePetVal(a, 'value');
            });
            let bundle = [], sum = 0;
            for (const p of sorted) {
                if (bundle.length >= maxPets) break;
                const v = calculatePetVal(p, 'value');
                if (sum + v <= targetVal * 1.18) { bundle.push(p); sum += v; }
                if (sum >= targetVal * 0.88) break;
            }
            return { bundle, sum };
        }

        // ‚îÄ‚îÄ MAIN AI SUGGESTIONS (v2) ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function updateAISuggestions(inventory) {
            const box = document.getElementById('aiSuggestions');
            const dreamContainer = document.getElementById('dreamPetContainer');
            const totalInvVal = parseFloat(document.getElementById('invTotalValue').innerText) || 0;
            const tier = getTierInfo(totalInvVal);

            // Dream Pet mode
            if (state.dreamPet) {
                dreamContainer.innerHTML = `<div class="dream-active-badge"><span>Target: ${state.dreamPet.n}</span><span style="cursor:pointer" onclick="clearDreamPet()">‚úï</span></div>`;
                const freshDream = ALL_PETS.find(x => x.n === state.dreamPet.n);
                const dreamVal = freshDream ? calculatePetVal({...freshDream, type:'reg', f_st:false, r_st:false}, 'value') : state.dreamPet.v;
                const pct = Math.min((totalInvVal / dreamVal) * 100, 100).toFixed(1);
                let html = `<div class="ai-summary"><b>Dream Progress:</b> ${pct}%<div class="dream-progress-bg"><div class="dream-progress-fill" style="width:${pct}%"></div></div></div>`;
                const candidates = [...inventory].sort((a,b) => calculatePetVal(b,'value') - calculatePetVal(a,'value'));
                const seen = new Set(); let combos = [];
                for (let start = 0; start < Math.min(candidates.length, 8); start++) {
                    let combo = [], sum = 0;
                    for (const p of candidates) {
                        if (combo.includes(p)) continue;
                        const v = calculatePetVal(p, 'value');
                        if (sum + v <= dreamVal * 1.12) { combo.push(p); sum += v; }
                        if (sum >= dreamVal * 0.85) break;
                    }
                    const key = combo.map(p=>p.uid).sort().join(',');
                    if (combo.length > 0 && !seen.has(key)) { seen.add(key); combos.push({ combo, sum, diff: Math.abs(dreamVal - sum) }); }
                }
                combos.sort((a,b) => a.diff - b.diff);
                box.innerHTML = html + (combos.length ? combos.slice(0,5).map(r => {
                    const diff = (dreamVal - r.sum).toFixed(2);
                    return `<div class="ai-suggestion" style="border-left-color:var(--rarity-legendary)"><b>Offer:</b> ${r.combo.map(getPetLabel).join(' + ')}<div class="ai-stats-row"><span class="ai-stat-pill" style="background:#334155;color:white">Total: ${r.sum.toFixed(2)}</span><span class="ai-stat-pill" style="color:${parseFloat(diff)>0?'var(--lose)':'var(--win)'}">Remaining: ${parseFloat(diff)>0?diff:'‚úÖ Covered'}</span></div></div>`;
                }).join('') : '<div class="ai-suggestion">Not enough inventory value to approach dream pet yet.</div>');
                return;
            } else {
                dreamContainer.innerHTML = `<button class="nav-btn" style="width:100%;font-size:0.8em;padding:8px" onclick="openSearch('dream')">‚òÖ Set Dream Pet</button>`;
            }

            // Filter out locked pets ‚Äî they won't appear in any AI suggestions
            inventory = inventory.filter(p => !lockedPets.has(p.n));

            if (inventory.length === 0) {
                box.innerHTML = `<div class="ai-suggestion">Add pets to your inventory to generate smart trade strategies. ${lockedPets.size > 0 ? '(' + lockedPets.size + ' pet' + (lockedPets.size > 1 ? 's' : '') + ' locked from AI)' : ''}</div>`;
                return;
            }

            // ‚îÄ‚îÄ INVENTORY HEALTH REPORT ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const health = getInventoryHealthReport(inventory);
            const tierMilestones = [
                { val:2, label:'Starter', color:'#94a3b8' }, { val:8, label:'Commons', color:'#81c784' },
                { val:25, label:'Mid-Tier', color:'#4fc3f7' }, { val:60, label:'High-Tier', color:'#fbbf24' },
                { val:130, label:'Premium', color:'#f06292' }, { val:300, label:'Top-Tier', color:'#a855f7' }
            ];
            const nextMilestone = tierMilestones.find(m => totalInvVal < m.val) || tierMilestones[tierMilestones.length-1];
            const prevMilestone = tierMilestones[Math.max(0, tierMilestones.indexOf(nextMilestone)-1)];
            const milePct = nextMilestone === prevMilestone ? 100 : Math.min(100, ((totalInvVal - prevMilestone.val) / (nextMilestone.val - prevMilestone.val) * 100)).toFixed(0);

            // Mega project detection
            const nfrGroups = {};
            inventory.forEach(p => { if (p.type === 'neon' && p.f_st && p.r_st) nfrGroups[p.n] = (nfrGroups[p.n]||0)+1; });
            const megaProject = Object.entries(nfrGroups).find(([,c]) => c >= 3);

            const invAvgDem = inventory.reduce((s,p) => s + (parseFloat(getEffDemand(p))||0), 0) / inventory.length;
            const invDemTier = invAvgDem >= 7 ? 'High' : invAvgDem >= 4 ? 'Mid' : 'Low';

            let html = `<div class="ai-summary">
                <div style="display:flex;justify-content:space-between;align-items:center;margin-bottom:6px">
                    <span><b>Tier:</b> ${tier.name} ¬∑ <b>Next:</b> ${nextMilestone.label} <span style="color:var(--subtext);font-size:0.85em">(${milePct}%)</span></span>
                    ${health ? `<span style="font-size:1.1em;font-weight:900;color:${health.gradeColor};border:2px solid ${health.gradeColor};border-radius:6px;padding:2px 8px">Grade: ${health.grade}</span>` : ''}
                </div>
                <div class="dream-progress-bg"><div class="dream-progress-fill" style="width:${milePct}%;background:${nextMilestone.color}"></div></div>
                <span style="font-size:0.8em;color:var(--subtext)">Path: ${tier.next}</span>
            </div>`;

            // Health breakdown
            if (health) {
                html += `<div style="background:#0f172a;border-radius:10px;padding:10px;margin-bottom:12px;border:1px solid #1e293b">
                    <div style="font-size:0.7em;font-weight:900;color:var(--accent);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">üìä Inventory Health Score: <span style="color:${health.gradeColor}">${health.score}/100 (${health.grade})</span></div>
                    ${health.breakdown.map(b => `
                        <div style="margin-bottom:5px">
                            <div style="display:flex;justify-content:space-between;font-size:0.72em;margin-bottom:2px">
                                <span style="color:#94a3b8">${b.label}</span>
                                <span style="color:white;font-weight:700">${b.score}/${b.max}</span>
                            </div>
                            <div style="background:#1e293b;border-radius:4px;height:5px">
                                <div style="background:${b.score/b.max >= 0.7 ? '#34d399' : b.score/b.max >= 0.4 ? '#fbbf24' : '#f87171'};width:${(b.score/b.max*100).toFixed(0)}%;height:100%;border-radius:4px;transition:width 0.4s"></div>
                            </div>
                            <div style="font-size:0.68em;color:#64748b;margin-top:2px">${b.tip}</div>
                        </div>
                    `).join('')}
                    <div style="margin-top:8px;border-top:1px solid #1e293b;padding-top:8px">
                        ${health.advice.map(a => `<div style="font-size:0.73em;color:#94a3b8;margin-bottom:3px">${a}</div>`).join('')}
                    </div>
                </div>`;
            }

            if (megaProject) {
                html += `<div class="ai-suggestion" style="border-left-color:#fbbf24">üî• <b>Mega Project:</b> You have ${megaProject[1]} NFR ${megaProject[0]}s ‚Äî just 1 more to make a MFR. Highest-value play available right now.</div>`;
            }

            // ‚îÄ‚îÄ PROACTIVE TARGETS SECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const proactive = getProactiveTargets(totalInvVal, 6);
            if (proactive.length > 0) {
                html += `<div style="font-size:0.7em;font-weight:900;color:#a855f7;text-transform:uppercase;letter-spacing:1px;margin:14px 0 8px">üîÆ BEST TARGETS IN YOUR RANGE RIGHT NOW</div>`;
                html += `<div style="display:flex;flex-wrap:wrap;gap:7px;margin-bottom:14px">`;
                proactive.forEach(({p, trend, liq}) => {
                    const tv = calculatePetVal({...p,type:'reg',f_st:false,r_st:false},'value');
                    const trendIcon = trend.direction === 'rising' ? 'üìà' : trend.direction === 'falling' ? 'üìâ' : '';
                    const catLabel = getCatLabel(p);
                    const catColor = catLabel === 'Exotic' ? '#a855f7' : catLabel === 'High Tier' ? '#fbbf24' : catLabel === 'Preppy' ? '#f472b6' : '#94a3b8';
                    html += `<div style="background:#0f172a;border:1px solid #1e293b;border-radius:8px;padding:6px 8px;cursor:pointer;min-width:90px;max-width:120px;text-align:center" onclick="openSearch('inv')" title="${p.n}">
                        ${petImgTag(p.n, 'width:36px;height:36px;object-fit:contain')}
                        <div style="font-size:0.72em;font-weight:800;color:white;margin-top:3px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis">${p.n}</div>
                        <div style="font-size:0.65em;color:${catColor}">${catLabel}</div>
                        <div style="font-size:0.65em;color:#94a3b8">Dem: ${p.d} ${trendIcon} ¬∑ ${tv.toFixed(1)}</div>
                    </div>`;
                });
                html += `</div>`;
            }

            // ‚îÄ‚îÄ DEMAND TIER ADVICE ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            const demTierAdvice = invDemTier === 'Low'
                ? 'Your inventory has low average demand ‚Äî prioritise trading into higher-demand pets even at a slight value loss.'
                : invDemTier === 'High' ? 'Strong demand across your inventory ‚Äî focus on value gain, you have trading leverage.'
                : 'Moderate demand. Aim for both value gain AND demand tier improvement where possible.';

            let results = [];
            const usedUids = new Set();
            // Never suggest a pet the user already owns as a target
            const invNames = new Set(inventory.map(p => p.n));

            if (state.aiMode === 'velocity') {
                // Velocity v2: uses liquidity score, trade frequency, stability
                const pool = [...inventory].sort((a,b) => calculatePetVal(b,'value') - calculatePetVal(a,'value'));
                for (let i = 0; i < pool.length && results.length < state.strategyLimit; i++) {
                    const anchor = pool[i];
                    if (usedUids.has(anchor.uid)) continue;
                    const anchorVal = calculatePetVal(anchor, 'value');
                    if (anchorVal <= 0) continue;
                    const targets = ALL_PETS
                        .filter(t => {
                            if (state.aiTargetPets.length > 0 && !state.aiTargetPets.some(x=>x.n===t.n)) return false;
                            if (invNames.has(t.n)) return false;            // never suggest a pet you already own
                            const tv = calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value');
                            const liq = getLiquidityScore(t.n);
                            return t.d >= 6.5                               // high demand required
                                && liq >= 0.2                               // must actually trade
                                && tv >= anchorVal * 0.82 && tv <= anchorVal * 1.25
                                && !isHTT(t.n);
                        })
                        .sort((a,b) => {
                            // Sort by composite: demand + liquidity
                            const lA = getLiquidityScore(a.n), lB = getLiquidityScore(b.n);
                            return (b.d * 0.6 + lB * 4) - (a.d * 0.6 + lA * 4);
                        })
                        .slice(0, 2);

                    for (const target of targets) {
                        if (results.length >= state.strategyLimit) break;
                        const tv = calculatePetVal({...target,type:'reg',f_st:false,r_st:false},'value');
                        const valGapPct = ((tv - anchorVal) / anchorVal * 100);
                        const tqs = scorePotentialTarget(target, anchorVal, parseFloat(getEffDemand(anchor)), [anchor]);
                        const acceptPct = getAcceptanceProbability(anchorVal, parseFloat(getEffDemand(anchor)), target, [anchor]);
                        results.push({ offer:[anchor], target, tqs, valGap:(tv-anchorVal).toFixed(2),
                            valGapPct: valGapPct.toFixed(1), bundleAvgDem: parseFloat(getEffDemand(anchor)),
                            acceptPct,
                            reason: buildReasonText(target, anchorVal, parseFloat(getEffDemand(anchor)), [anchor]) });
                    }
                    usedUids.add(anchor.uid);
                }
            } else {
                // Normal mode v2
                const bundleSizes = [1, 2, 3, 4];
                const invSorted = [...inventory].sort((a,b) => {
                    const dA = parseFloat(getEffDemand(a)), dB = parseFloat(getEffDemand(b));
                    if (dB !== dA) return dB - dA;
                    return calculatePetVal(b,'value') - calculatePetVal(a,'value');
                });

                for (const bundleSize of bundleSizes) {
                    if (results.length >= state.strategyLimit) break;
                    const avail = invSorted.filter(p => !usedUids.has(p.uid));
                    if (avail.length < bundleSize) continue;

                    for (let start = 0; start < Math.min(avail.length, 6); start++) {
                        if (results.length >= state.strategyLimit) break;
                        let bundle = [], sum = 0;
                        const anchor = avail[start];
                        bundle.push(anchor);
                        sum += calculatePetVal(anchor, 'value');
                        if (bundleSize > 1) {
                            for (const p of avail) {
                                if (bundle.length >= bundleSize || bundle.includes(p)) continue;
                                sum += calculatePetVal(p, 'value');
                                bundle.push(p);
                            }
                        }
                        if (bundle.length < bundleSize || sum <= 0) continue;

                        const bundleAvgDem = bundle.reduce((s,p)=>s+parseFloat(getEffDemand(p)),0) / bundle.length;
                        const bundleTier   = getBundleTier(bundle);
                        const bundleReadability = getBundleReadabilityScore(bundle);

                        // Value tolerance scales with pet value
                        const maxLoss = sum >= 200 ? 0.03 : sum >= 50 ? 0.05 : 0.08;

                        const candidates = ALL_PETS.filter(t => {
                            if (state.aiTargetPets.length > 0 && !state.aiTargetPets.some(x=>x.n===t.n)) return false;
                            if (invNames.has(t.n)) return false;            // never suggest a pet you already own
                            // Also exclude pets in the current bundle offer
                            if (bundle.some(p => p.n === t.n)) return false;
                            const tv = calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value');
                            if (tv > sum * 1.40 || tv < sum * (1 - maxLoss)) return false;
                            if (bundleAvgDem >= 7 && t.d < 4) return false;
                            if (bundleAvgDem >= 5 && t.d < 2) return false;
                            const targetTier = getCatTier(t);
                            if (bundleTier >= 3 && targetTier < 2 && t.d < 6) return false;
                            return tv > 0;
                        });

                        if (candidates.length === 0) continue;

                        const best = candidates
                            .map(t => ({ t,
                                tv: calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value'),
                                tqs: scorePotentialTarget(t, sum, bundleAvgDem, bundle) }))
                            .filter(x => x.tqs >= 3.5)
                            .sort((a,b) => b.tqs - a.tqs)[0];

                        if (!best) continue;

                        const valGapPct = ((best.tv - sum) / sum * 100);
                        const isDupe = results.some(r => r.target.n === best.t.n && Math.abs(r.valGapPct - valGapPct) < 5);
                        if (isDupe) continue;

                        const acceptPct = getAcceptanceProbability(sum, bundleAvgDem, best.t, bundle);

                        results.push({
                            offer: bundle, target: best.t, tqs: best.tqs,
                            valGap: (best.tv - sum).toFixed(2),
                            valGapPct: valGapPct.toFixed(1),
                            bundleAvgDem, sum, acceptPct,
                            bundleReadability,
                            reason: buildReasonText(best.t, sum, bundleAvgDem, bundle)
                        });
                    }
                }
            }

            // ‚îÄ‚îÄ SMART DOWNGRADE SECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let downgrades = [];
            const highValPets = [...inventory]
                .filter(p => calculatePetVal(p,'value') >= 5)
                .sort((a,b) => calculatePetVal(b,'value') - calculatePetVal(a,'value'))
                .slice(0, 5);

            for (const anchor of highValPets) {
                const anchorVal = calculatePetVal(anchor, 'value');
                const anchorDem = parseFloat(getEffDemand(anchor));
                for (let count = 2; count <= 4; count++) {
                    const perPetTarget = anchorVal / count;
                    const receivables = ALL_PETS.filter(t => {
                        if (t.n === anchor.n) return false;
                        const tv = calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value');
                        if (tv < perPetTarget * 0.5 || tv > perPetTarget * 1.5) return false;
                        if (t.d < 5 || isHTT(t.n)) return false;
                        return true;
                    }).sort((a,b) => {
                        const lA = getLiquidityScore(a.n), lB = getLiquidityScore(b.n);
                        return (b.d * 0.5 + lB * 5) - (a.d * 0.5 + lA * 5);
                    }).slice(0, 8);

                    if (receivables.length < count) continue;
                    const combo = receivables.slice(0, count);
                    const comboVal = combo.reduce((s,t) => s + calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value'), 0);
                    const comboAvgDem = combo.reduce((s,t)=>s+t.d,0) / count;
                    const comboAvgLiq = combo.reduce((s,t)=>s+getLiquidityScore(t.n),0) / count;

                    if (comboVal < anchorVal * 0.97 || comboAvgDem < 5) continue;

                    const valGainPct = ((comboVal - anchorVal) / anchorVal * 100).toFixed(1);
                    const demGain    = (comboAvgDem - anchorDem).toFixed(1);
                    const isDupe = downgrades.some(d => d.anchor.n === anchor.n);
                    if (isDupe) continue;

                    downgrades.push({ anchor, combo, comboVal, comboAvgDem, comboAvgLiq, valGainPct, demGain, anchorVal });
                    break;
                }
            }

            // ‚îÄ‚îÄ CHAIN TRADE SECTION ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            let chainTrade = null;
            if (results.length < 2 && inventory.length > 0) {
                // Only suggest chain trade if direct suggestions are sparse
                const topCat = results[0]?.target ? getCatLabel(results[0].target) : 'High Tier';
                chainTrade = findChainTrade(inventory, totalInvVal, 6, topCat);
            }

            // ‚îÄ‚îÄ RENDER ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
            if (results.length === 0 && downgrades.length === 0) {
                html += `<div style="font-size:0.75em;color:var(--subtext);margin-bottom:10px;padding:8px;background:#0f172a;border-radius:8px">${demTierAdvice}</div>`;
                html += `<div class="ai-suggestion">No suitable trades found. Try adding more pets or switching to Velocity Mode.</div>`;
                box.innerHTML = html;
                return;
            }

            if (results.length > 0) {
                html += `<div style="font-size:0.75em;color:var(--subtext);margin-bottom:10px;padding:8px;background:#0f172a;border-radius:8px">${demTierAdvice}</div>`;
                html += `<div style="font-size:0.7em;font-weight:900;color:var(--accent);text-transform:uppercase;letter-spacing:1px;margin-bottom:8px">üìà UPGRADE TRADES</div>`;
            }

            results.forEach(r => {
                const catLabel  = getCatLabel(r.target);
                const catBadge  = catLabel === 'High Tier' ? 'badge-hightier' : catLabel === 'Preppy' ? 'badge-preppy' : catLabel === 'Exotic' ? 'badge-exotic' : 'badge-randoms';
                const tqsCls    = r.tqs >= 7 ? 'high' : r.tqs >= 4 ? 'mid' : 'low';
                const tqsLabel  = r.tqs >= 7 ? 'üî• Strong' : r.tqs >= 4 ? '„ÄΩÔ∏è Decent' : '‚ö†Ô∏è Weak';
                const isRising  = r.target.vt && r.target.vt.includes('üìà');
                const isFalling = r.target.dt && r.target.dt.includes('‚ùÑÔ∏è');
                const ugly      = isHTT(r.target.n);
                const manip     = !!getManipulationFlag(r.target.n);
                const valGapNum = parseFloat(r.valGapPct);
                const valColor  = valGapNum >= 0 ? 'var(--win)' : 'var(--lose)';
                const bundleVal = (r.sum || r.offer.reduce((s,p)=>s+calculatePetVal(p,'value'),0)).toFixed(2);
                const targetVal = calculatePetVal({...r.target,type:'reg',f_st:false,r_st:false},'value').toFixed(2);
                const acceptColor = r.acceptPct >= 65 ? '#34d399' : r.acceptPct >= 40 ? '#fbbf24' : '#f87171';
                const readScore = r.bundleReadability !== undefined ? r.bundleReadability : 10;
                const readLabel = readScore >= 8 ? '‚úÖ Clean' : readScore >= 5 ? '„ÄΩÔ∏è OK' : '‚ö†Ô∏è Messy';
                const targetTrend = getCachedTrend(r.target.n);

                html += `<div class="ai-suggestion">
                    <div style="margin-bottom:5px">
                        <span style="font-size:0.8em;color:var(--subtext)">You offer:</span>
                        <span style="font-weight:800;color:#cbd5e1;font-size:0.85em"> ${r.offer.map(getPetLabel).join(' + ')}</span>
                        <span style="font-size:0.75em;color:var(--subtext);margin-left:5px">(${bundleVal})</span>
                        ${r.offer.length >= 4 ? '<span style="font-size:0.7em;color:var(--trap);margin-left:4px">‚ö†Ô∏è large bundle</span>' : ''}
                    </div>
                    <div style="display:flex;align-items:center;gap:7px;margin-bottom:5px">
                        ${petImgTag(r.target.n, "width:30px;height:30px;object-fit:contain;border-radius:6px;background:#0f172a")}
                        <div>
                            <span style="font-size:0.8em;color:var(--subtext)">For:</span>
                            <span style="font-weight:900;color:white"> ${r.target.n}</span>
                            <span style="font-size:0.75em;color:var(--subtext);margin-left:4px">(${targetVal})</span>
                        </div>
                        <span class="target-badge ${catBadge}">${catLabel}</span>
                        ${isRising  ? '<span class="target-badge badge-rising">üìà</span>' : ''}
                        ${isFalling ? '<span class="target-badge badge-falling">‚ùÑÔ∏è</span>' : ''}
                        ${ugly   ? '<span class="target-badge badge-ugly">HTT</span>' : ''}
                        ${manip  ? '<span class="target-badge badge-manip">‚ö†Ô∏èSpike</span>' : ''}
                        ${targetTrend.acceleration > 8 ? '<span class="target-badge badge-rising">üöÄAccel</span>' : ''}
                    </div>
                    <div style="font-size:0.73em;color:#94a3b8;margin-bottom:5px">${r.reason}</div>
                    <div class="ai-stats-row">
                        <span class="ai-stat-pill tqs-${tqsCls}">${tqsLabel} ${r.tqs.toFixed(1)}/10</span>
                        <span class="ai-stat-pill" style="color:${valColor};background:rgba(255,255,255,0.05)">${valGapNum>=0?'+':''}${r.valGapPct}%</span>
                        <span class="ai-stat-pill pill-dem">Dem: ${r.target.d.toFixed(1)}</span>
                        <span class="ai-stat-pill" style="color:${acceptColor};background:rgba(255,255,255,0.05)">~${r.acceptPct}% accept</span>
                        <span class="ai-stat-pill" style="color:${readScore>=8?'#34d399':readScore>=5?'#fbbf24':'#f87171'};background:rgba(255,255,255,0.05)">Bundle: ${readLabel}</span>
                    </div>
                </div>`;
            });

            // Chain trade suggestion
            if (chainTrade) {
                html += `<div class="ai-suggestion" style="border-left-color:#06b6d4;margin-top:4px">
                    <div style="font-size:0.7em;font-weight:900;color:#06b6d4;text-transform:uppercase;letter-spacing:1px;margin-bottom:6px">‚õìÔ∏è 2-STEP CHAIN TRADE</div>
                    <div style="font-size:0.82em;color:#cbd5e1;margin-bottom:4px">
                        Step 1: Trade inventory ‚Üí <b>${chainTrade.bridge.n}</b> (${chainTrade.bridgeVal.toFixed(2)}, Dem ${chainTrade.bridge.d})
                    </div>
                    <div style="font-size:0.82em;color:#cbd5e1">
                        Step 2: Use <b>${chainTrade.bridge.n}</b> ‚Üí <b>${chainTrade.step2.n}</b> (Dem ${chainTrade.step2.d}, ${getCatLabel(chainTrade.step2)})
                    </div>
                    <div style="font-size:0.73em;color:#94a3b8;margin-top:4px">Sometimes the direct path doesn't exist ‚Äî use a liquid bridge pet to unlock the trade.</div>
                </div>`;
            }

            // Smart downgrades
            if (downgrades.length > 0) {
                html += `<div style="font-size:0.7em;font-weight:900;color:#f59e0b;text-transform:uppercase;letter-spacing:1px;margin:14px 0 8px">‚¨áÔ∏è SMART DOWNGRADES (gain liquidity)</div>`;
                downgrades.forEach(d => {
                    const valGainNum = parseFloat(d.valGainPct);
                    const demGainNum = parseFloat(d.demGain);
                    const gainColor  = valGainNum >= 0 ? 'var(--win)' : 'var(--lose)';
                    const demColor   = demGainNum > 0 ? 'var(--win)' : demGainNum < -1 ? 'var(--lose)' : 'var(--subtext)';
                    html += `<div class="ai-suggestion" style="border-left-color:#f59e0b">
                        <div style="margin-bottom:4px">
                            <span style="font-size:0.8em;color:var(--subtext)">Give:</span>
                            <span style="font-weight:800;color:#cbd5e1"> ${getPetLabel(d.anchor)}</span>
                            <span style="font-size:0.75em;color:var(--subtext);margin-left:4px">(${d.anchorVal.toFixed(2)})</span>
                        </div>
                        <div style="margin-bottom:5px">
                            <span style="font-size:0.8em;color:var(--subtext)">Receive:</span>
                            <span style="font-weight:800;color:#fbbf24"> ${d.combo.map(t=>t.n).join(' + ')}</span>
                            <span style="font-size:0.75em;color:var(--subtext);margin-left:4px">(${d.comboVal.toFixed(2)})</span>
                        </div>
                        <div style="font-size:0.73em;color:#94a3b8;margin-bottom:5px">1 pet ‚Üí ${d.combo.length} faster-moving pets ¬∑ avg demand ${d.comboAvgDem.toFixed(1)} ¬∑ liquidity ${(d.comboAvgLiq*100).toFixed(0)}%</div>
                        <div class="ai-stats-row">
                            <span class="ai-stat-pill" style="color:${gainColor};background:rgba(255,255,255,0.05)">Value: ${valGainNum>=0?'+':''}${d.valGainPct}%</span>
                            <span class="ai-stat-pill" style="color:${demColor};background:rgba(255,255,255,0.05)">Dem: ${demGainNum>=0?'+':''}${d.demGain}</span>
                            <span class="ai-stat-pill" style="background:#1e3a1e;color:#6ee7b7">${d.combo.length} received</span>
                        </div>
                    </div>`;
                });
            }

            box.innerHTML = html;
        }



                function renderSide(s) {
            const list = state[s];
            const grid = document.getElementById(`grid${s}`);
            grid.innerHTML = '';
            let totalV = 0, totalD = 0;
            list.forEach(p => {
                let currentDemand = p.type === 'neon' ? (p.nd || p.d) : (p.type === 'mega' ? (p.md || p.d) : p.d);
                let val = calculatePetVal(p, state.mode);
                totalV += val; totalD += currentDemand;
                const imgUrl = `https://amvgg.com/items/${encodeURIComponent(p.n)}.webp`;
                const imgTag = petImgTag(p.n, 'width:100%;height:100%;object-fit:contain');
                const rarityColor = getRarityColor(p.cat);
                const demandColor = getDemandColor(currentDemand);
                grid.innerHTML += `
                    <div class="card" style="border-color: ${rarityColor}">
                        <div class="del" onclick="remove('${s}', ${p.uid})">‚úï</div>
                        <div class="card-img-container" 
                             oncontextmenu="handlePetContext(event, ${JSON.stringify(p).replace(/"/g, '&quot;')})"
                             ondblclick="duplicate('${s}', ${p.uid})" title="Right click for Qty | Shift + Right click for Graph">
                            ${imgTag}
                        </div>
                        <div class="card-name">${p.n}${getTrendIcons(p)}</div>
                        <div class="card-val">${val.toFixed(2)}</div>
                        <div class="card-demand" style="color: ${demandColor}">Dem: ${currentDemand}</div>
                        <div class="toggles">
                            <div class="t-btn ${p.type==='neon'?'active':''}" onclick="tog('${s}',${p.uid},'n')">N</div>
                            <div class="t-btn ${p.type==='mega'?'active':''}" onclick="tog('${s}',${p.uid},'m')">M</div>
                            <div class="t-btn ${p.f_st?'active':''}" onclick="tog('${s}',${p.uid},'f')">F</div>
                            <div class="t-btn ${p.r_st?'active':''}" onclick="tog('${s}',${p.uid},'r')">R</div>
                        </div>
                    </div>`;
            });
            grid.innerHTML += `<div class="plus" onclick="openSearch('${s}')">+</div>`;
            document.getElementById(`tot${s}`).innerText = totalV.toFixed(2);
            document.getElementById(`cnt${s}`).innerText = list.length;
            document.getElementById(`dem${s}`).innerText = list.length > 0 ? (totalD / list.length).toFixed(1) : "0.0";
        }

        function calculate() {
            const vA = parseFloat(document.getElementById('totA').innerText);
            const vB = parseFloat(document.getElementById('totB').innerText);
            const demA = parseFloat(document.getElementById('demA').innerText);
            const demB = parseFloat(document.getElementById('demB').innerText);
            const verdict = document.getElementById('verdict'), vDiff = document.getElementById('vDiff'), vSub = document.getElementById('vSub');
            const gaugeNeedle = document.getElementById('gaugeNeedle');
            const gaugeBar = document.getElementById('gaugeBar');
            let isTrap = false;
            if (vA === 0 && vB === 0) { verdict.innerText = "--"; verdict.className = "v-text"; gaugeNeedle.style.left = "50%"; gaugeBar.classList.remove('trap-active'); return; }
            const diff = vB - vA, pDiff = vA > 0 ? (diff / vA) : (vB > 0 ? 1.0 : 0);
            const demGap = demA - demB;
            let needlePos = 50 + (pDiff / 0.15 * 50);
            if (needlePos < 0) needlePos = 0; if (needlePos > 100) needlePos = 100;
            gaugeNeedle.style.left = `${needlePos}%`;
            if (Math.abs(diff) < 0.01) { verdict.innerText = "FAIR"; verdict.className = "v-text fair-c"; vSub.innerText = "The trade is perfectly balanced in value. No one gain or loses raw wealth."; }
            else if (diff > 0) {
                if (demGap >= 3 && pDiff < 0.4) { verdict.innerText = "TRAP"; verdict.className = "v-text trap-c"; vSub.innerText = `DANGER: You are gaining ${diff.toFixed(2)} value, but losing ${demGap.toFixed(1)} demand points. These pets will be extremely hard to trade away later. Avoid unless you love them.`; isTrap = true; }
                else {
                    const hasSpecial = state.B.some(p => { const c = (p.cat || "").toLowerCase(); return c.includes('legendary') || c.includes('preppy') || c.includes('exotic'); });
                    if (demB > 0 && demB <= 3 && !hasSpecial && pDiff < 1.5) { verdict.innerText = "TRAP"; verdict.className = "v-text trap-c"; vSub.innerText = "VALUE BAIT: They are offering low-demand 'trash' pets. You need a much higher overpay (1.5x+) to make this even remotely fair."; isTrap = true; } 
                    else { verdict.innerText = pDiff >= 0.15 ? "BIG WIN" : "WIN"; verdict.className = "v-text win-c"; let demTxt = demB > demA ? "and you are gaining trading speed (Demand Up)!" : "but be aware you are losing a bit of trading speed."; vSub.innerText = `You are gaining ${(pDiff * 100).toFixed(1)}% in raw value ${demTxt}`; playSfx('win'); }
                }
            } else {
                verdict.innerText = pDiff <= -0.15 ? "BIG LOSE" : "LOSE"; verdict.className = "v-text lose-c";
                if (demB >= demA + 2) { vSub.innerText = `STRATEGIC OVERPAY: You lose value, but gain massive trading velocity (+${(demB - demA).toFixed(1)} Dem). This is a good move to clear stagnant pets.`; }
                else { vSub.innerText = `You are losing ${(Math.abs(pDiff) * 100).toFixed(1)}% of your value with no significant demand gain. This is a bad deal.`; }
            }
            vDiff.innerText = `Difference: ${diff > 0 ? "+" : ""}${diff.toFixed(2)} (${(pDiff * 100).toFixed(1)}%)`;
            if (isTrap) gaugeBar.classList.add('trap-active'); else gaugeBar.classList.remove('trap-active');
            updateVerdictExtras();
        }

        function render() { renderSide('A'); renderSide('B'); calculate(); updateTradeSuggestions(); }
        function setMode(m) { state.mode = 'value'; document.getElementById('btnValue').classList.add('active'); render(); }
        function tog(s, uid, type) {
            pushState(); const p = state[s].find(x => x.uid === uid);
            if (!p) return;
            if (type === 'n') p.type = p.type === 'neon' ? 'reg' : 'neon';
            else if (type === 'm') p.type = p.type === 'mega' ? 'reg' : 'mega';
            else if (type === 'f') p.f_st = !p.f_st;
            else if (type === 'r') p.r_st = !p.r_st;
            saveTrade(); if (s === 'inv') renderInventory(); else render();
        }

        function updateTradeSuggestions() {
            const container = document.getElementById('sideASuggestions');
            const list = document.getElementById('suggestList');
            const targetVal = parseFloat(document.getElementById('totB').innerText);
            if (targetVal <= 0 || state.inv.length === 0) { container.style.display = 'none'; return; }
            container.style.display = 'block'; list.innerHTML = '';
            let pool = [...state.inv].sort(() => Math.random() - 0.5);
            for (let i = 0; i < 3; i++) {
                let bundle = [], sum = 0;
                for (let p of pool) {
                    let v = calculatePetVal(p, state.mode);
                    if (sum + v <= targetVal * 1.15) { bundle.push(p); sum += v; }
                    if (sum >= targetVal * 0.9) break;
                }
                if (bundle.length > 0) {
                    list.innerHTML += `<div class="suggest-pill" onclick='applySuggestion(${JSON.stringify(bundle.map(b=>b.uid))})'><div class="suggest-items-text">${bundle.map(b=>b.n).join(' + ')}</div><div class="suggest-val-text">${sum.toFixed(2)}</div></div>`;
                }
            }
        }

        function applySuggestion(uids) {
            pushState(); uids.forEach(uid => {
                const item = state.inv.find(x => x.uid === uid);
                if (item) state.A.push({...item, uid: Math.random()});
            });
            render(); saveTrade();
        }

        // ===================================================
        // NEW FEATURES ‚Äî Added on top of original code
        // ===================================================

        // Feature 1 & 2 & 3 & 4 & 5: Verdict Extras
        function getTradeSpeed(avgDemand) {
            if (avgDemand > 7)  return { label: 'Fast',     cls: 'speed-fast', emoji: '‚ö°' };
            if (avgDemand >= 4) return { label: 'Moderate', cls: 'speed-mod',  emoji: '‚è±Ô∏è' };
            return                     { label: 'Slow',     cls: 'speed-slow', emoji: 'üê¢' };
        }

        function getFlipScore(sideList) {
            if (!sideList || sideList.length === 0) return null;
            // One high-demand pet scores higher than many low-demand ones
            const avgDem = sideList.reduce((s, p) => {
                const d = p.type === 'neon' ? (p.nd || p.d) : (p.type === 'mega' ? (p.md || p.d) : p.d);
                return s + d;
            }, 0) / sideList.length;
            // Penalise for having many pets (harder to flip a stack)
            const countPenalty = Math.max(0, (sideList.length - 1) * 0.5);
            const raw = avgDem - countPenalty;
            let label, cls;
            if (raw >= 6.5) { label = 'üî• High Flip Potential'; cls = 'flip-high'; }
            else if (raw >= 4) { label = '„ÄΩÔ∏è Moderate Flip Potential'; cls = 'flip-med'; }
            else { label = 'üßä Low Flip Potential'; cls = 'flip-low'; }
            return { label, cls, raw };
        }

        function updateVerdictExtras() {
            const box = document.getElementById('verdictExtras');
            const vA = parseFloat(document.getElementById('totA').innerText) || 0;
            const vB = parseFloat(document.getElementById('totB').innerText) || 0;
            if (vA === 0 && vB === 0) { box.innerHTML = ''; return; }

            const listA = state.A, listB = state.B;
            const cntA = listA.length, cntB = listB.length;
            let html = '';

            if (cntA > 0 && cntB > 0) {
                const avgDemB = listB.reduce((s,p) => s + (p.d || 0), 0) / cntB;
                const pDiff = vA > 0 ? (vB - vA) / vA : 0; // positive = you gain value

                // --- Downgrade Detection (one-for-many only) ---
                if (cntA === 1 && cntB >= 2) {
                    if (avgDemB < 4) {
                        html += `<span class="trade-type-tag tag-downgrade">‚¨áÔ∏è DOWNGRADE ‚Äî Splitting into low-demand stack</span>`;
                    } else {
                        html += `<span class="trade-type-tag tag-downgrade">‚¨áÔ∏è DOWNGRADE ‚Äî One-for-Many</span>`;
                    }
                }

                // --- Stack Penalty (RECEIVING side only, and only if NOT a big overpay) ---
                // If they give you 3+ low-demand pets and you're not getting significantly more value, flag it.
                // But if you're giving the stack (as overpay), don't penalise ‚Äî that's expected.
                if (cntB >= 3) {
                    const avgDemReceiving = listB.reduce((s,p) => s + (p.d||0), 0) / cntB;
                    // Only warn if the value you receive is NOT a huge overpay for you
                    // i.e. you're getting a stack that's roughly even or worse in value
                    const youAreGettingStack = true; // cntB is the receiving side
                    if (avgDemReceiving < 5 && pDiff < 0.35) {
                        html += `<span class="trade-type-tag tag-penalty">‚ö†Ô∏è STACK WARNING ‚Äî Receiving ${cntB} low-demand pets that will be hard to move</span>`;
                    }
                }

                // --- Getting Played Alert (low-demand stack dump only) ---
                const lowDemReceiving = listB.filter(p => (p.d || 0) < 4).length;
                if (cntB >= 4 && lowDemReceiving >= 3 && cntB > cntA && pDiff < 0.4) {
                    html += `<span class="trade-type-tag tag-played">üö© GETTING PLAYED ‚Äî Receiving ${cntB} pets, ${lowDemReceiving} have low demand</span>`;
                }
            }

            // --- Trade Speed Estimate ---
            const rawDemA = document.getElementById('demA').innerText.replace('Avg Demand: ', '') || '0';
            const rawDemB = document.getElementById('demB').innerText.replace('Avg Demand: ', '') || '0';
            const avgDA = parseFloat(rawDemA) || 0;
            const avgDB = parseFloat(rawDemB) || 0;
            if (cntA > 0 || cntB > 0) {
                const sA = getTradeSpeed(avgDA), sB = getTradeSpeed(avgDB);
                html += `<div class="speed-row">
                    <span class="speed-pill ${sA.cls}">${sA.emoji} You Give: ${sA.label}</span>
                    <span class="speed-pill ${sB.cls}">${sB.emoji} You Receive: ${sB.label}</span>
                </div>`;
            }

            // --- Flip Potential Score (Side B = what you receive) ---
            if (cntB > 0) {
                const fp = getFlipScore(listB);
                if (fp) {
                    html += `<div class="flip-row">Flip Potential: <span class="${fp.cls}">${fp.label}</span></div>`;
                }
            }

            box.innerHTML = html;
        }

        // ===================================================
        // Feature 6: Smarter search helpers
        // ===================================================
        function getTrendingPets(limit = 5) {
            // v2: uses actual trend velocity + demand + liquidity
            return [...ALL_PETS]
                .map(p => {
                    const trend = getCachedTrend(p.n);
                    const liq   = getLiquidityScore(p.n);
                    let score = 0;
                    score += (p.d || 0) * 1.5;
                    score += trend.pctChange * 0.4;
                    score += (trend.acceleration > 0 ? trend.acceleration * 0.2 : trend.acceleration * 0.1);
                    score += liq * 10;
                    if ((p.vt||'').includes('üìà')) score += 4;
                    if ((p.dt||'').includes('üî•')) score += 4;
                    if ((p.vt||'').includes('üìâ')) score -= 5;
                    if ((p.dt||'').includes('‚ùÑÔ∏è')) score -= 5;
                    if (isHTT(p.n)) score -= 10;
                    return { p, score };
                })
                .filter(x => x.score > 0 && !isHTT(x.p.n))
                .sort((a, b) => b.score - a.score)
                .slice(0, limit)
                .map(x => x.p);
        }

        function smartSortPets(list, query) {
            const HIGH_CATS = ['high tier', 'preppy'];
            return list.slice().sort((a, b) => {
                // 1. Demand score
                const dDiff = (b.d || 0) - (a.d || 0);
                if (Math.abs(dDiff) >= 1) return dDiff;
                // 2. Recent trend momentum
                const mA = ((a.vt||'').includes('üìà') ? 2 : 0) + ((a.dt||'').includes('üî•') ? 2 : 0);
                const mB = ((b.vt||'').includes('üìà') ? 2 : 0) + ((b.dt||'').includes('üî•') ? 2 : 0);
                if (mA !== mB) return mB - mA;
                // 3. Category preference
                const catA = HIGH_CATS.some(c => (a.cat||'').includes(c)) ? 1 : 0;
                const catB = HIGH_CATS.some(c => (b.cat||'').includes(c)) ? 1 : 0;
                if (catA !== catB) return catB - catA;
                return 0;
            });
        }


        // ================================================================
        // TRADE ADVISOR ‚Äî Full smart popup
        // ================================================================
        let advisorOfferPets = [];
        let advisorCharts = {};

        function openTradeAdvisor() {
            document.getElementById('advisorOverlay').style.display = 'flex';
            advisorOfferPets = [];
            renderAdvisorOffer();
            renderAdvisorInvGrid();
            refreshAdvisorTargets();
        }

        function closeTradeAdvisor() {
            document.getElementById('advisorOverlay').style.display = 'none';
        }

        function renderAdvisorInvGrid() {
            const grid = document.getElementById('advisorInvGrid');
            if (state.inv.length === 0) {
                grid.innerHTML = '<div style="text-align:center;color:var(--subtext);font-size:0.8em;grid-column:1/-1;padding:20px">Add pets to your inventory first.</div>';
                return;
            }
            // Group by name+type+f+r, show stack count
            const groups = {};
            state.inv.forEach(p => {
                const key = `${p.n}|${p.type}|${p.f_st}|${p.r_st}`;
                if (!groups[key]) groups[key] = { pet: p, count: 0 };
                groups[key].count++;
            });
            grid.innerHTML = Object.values(groups).sort((a,b) => calculatePetVal(b.pet,'value') - calculatePetVal(a.pet,'value')).map(({pet:p, count}) => {
                const val = calculatePetVal(p, 'value');
                const label = getPetLabel(p);
                return `<div class="advisor-inv-chip" onclick="advisorAddPet('${p.n.replace(/'/g,"\'")}','${p.type}',${p.f_st},${p.r_st})" title="Click to add to offer">
                    ${petImgTag(p.n, "width:38px;height:38px;object-fit:contain")}
                    ${count > 1 ? `<div style="position:absolute;top:3px;right:3px;background:var(--accent);color:white;border-radius:5px;font-size:9px;padding:1px 4px;font-weight:900">x${count}</div>` : ''}
                    <div class="inv-chip-name">${label.length > 14 ? label.substring(0,12)+'‚Ä¶' : label}</div>
                    <div class="inv-chip-val">${val.toFixed(2)}</div>
                </div>`;
            }).join('');
        }

        function advisorAddPet(name, type, f_st, r_st) {
            if (advisorOfferPets.length >= 6) return;
            const pet = ALL_PETS.find(x => x.n === name);
            if (!pet) return;
            advisorOfferPets.push({ ...pet, type: type || 'reg', f_st: !!f_st, r_st: !!r_st, uid: Math.random() });
            renderAdvisorOffer();
            refreshAdvisorTargets();
        }

        function advisorRemovePet(uid) {
            advisorOfferPets = advisorOfferPets.filter(p => p.uid !== uid);
            renderAdvisorOffer();
            refreshAdvisorTargets();
        }

        function renderAdvisorOffer() {
            const slotsEl = document.getElementById('advisorOfferSlots');
            const statsEl = document.getElementById('advisorOfferStats');
            let html = '';
            advisorOfferPets.forEach(p => {
                const val = calculatePetVal(p, 'value');
                const label = getPetLabel(p);
                html += `<div class="advisor-pet-chip" onclick="advisorRemovePet(${p.uid})" title="Click to remove">
                    <div class="chip-remove">‚úï</div>
                    ${petImgTag(p.n, "width:38px;height:38px;object-fit:contain")}
                    <div class="chip-name">${label.length > 12 ? label.substring(0,11)+'‚Ä¶' : label}</div>
                    <div class="chip-val">${val.toFixed(2)}</div>
                </div>`;
            });
            // Empty slots
            for (let i = advisorOfferPets.length; i < 6; i++) {
                html += `<div class="advisor-add-slot" onclick="advisorFocusInv()">+</div>`;
            }
            slotsEl.innerHTML = html;

            if (advisorOfferPets.length === 0) {
                statsEl.innerHTML = '<div style="text-align:center;color:var(--subtext);font-size:0.82em">Add pets from below to build your offer</div>';
                return;
            }
            const totalVal = advisorOfferPets.reduce((s,p) => s + calculatePetVal(p,'value'), 0);
            const avgDem = advisorOfferPets.reduce((s,p) => s + (p.d||0), 0) / advisorOfferPets.length;
            const demTier = avgDem >= 7 ? '<span style="color:#34d399">High</span>' : avgDem >= 4 ? '<span style="color:#fbbf24">Mid</span>' : '<span style="color:#f87171">Low</span>';
            const bundleWarn = advisorOfferPets.length > 4 ? '<div style="color:var(--trap);font-size:0.8em;margin-top:4px">‚ö†Ô∏è 5+ pet bundles are hard to accept</div>' : '';
            statsEl.innerHTML = `
                <div class="advisor-stat-row"><span class="advisor-stat-label">Total Value</span><span class="advisor-stat-val">${totalVal.toFixed(2)}</span></div>
                <div class="advisor-stat-row"><span class="advisor-stat-label">Avg Demand</span><span class="advisor-stat-val">${avgDem.toFixed(1)} (${demTier} tier)</span></div>
                <div class="advisor-stat-row"><span class="advisor-stat-label">Pets in Offer</span><span class="advisor-stat-val">${advisorOfferPets.length}/6</span></div>
                ${bundleWarn}`;
        }

        function advisorFocusInv() {
            document.getElementById('advisorInvGrid').scrollIntoView({ behavior: 'smooth', block: 'nearest' });
        }

        function refreshAdvisorTargets() {
            const resultsEl = document.getElementById('advisorResults');
            const insightEl = document.getElementById('advisorInsightBar');

            if (advisorOfferPets.length === 0) {
                resultsEl.innerHTML = '<div class="advisor-empty">Add pets from your inventory to your offer on the left, then smart targets will appear here.</div>';
                insightEl.textContent = 'Build your offer to see tailored trade recommendations.';
                return;
            }

            const offerVal  = advisorOfferPets.reduce((s,p) => s + calculatePetVal(p,'value'), 0);
            const offerAvgD = advisorOfferPets.reduce((s,p) => s + (p.d||0), 0) / advisorOfferPets.length;
            const demandMin = parseFloat(document.getElementById('advisorDemandFilter').value) || 0;
            const catFilter = document.getElementById('advisorCatFilter').value;
            const window    = parseFloat(document.getElementById('advisorWindowFilter').value) || 0.20;
            const sortBy    = document.getElementById('advisorSortFilter').value;

            // Filter candidates
            let candidates = ALL_PETS.filter(t => {
                const tVal = calculatePetVal({...t, type:'reg', f_st:false, r_st:false}, 'value');
                if (tVal < offerVal * (1 - window) || tVal > offerVal * (1 + window)) return false;
                if (t.d < demandMin) return false;
                if (catFilter !== 'all' && !(t.cat||'').toLowerCase().includes(catFilter)) return false;
                // Exclude pets already in offer
                if (advisorOfferPets.some(p => p.n === t.n)) return false;
                if (state.inv.some(p => p.n === t.n)) return false; // don't suggest what you already own
                return true;
            });

            // Score all candidates
            candidates = candidates.map(t => ({
                pet: t,
                tqs: scorePotentialTarget(t, offerVal, offerAvgD, advisorOfferPets),
                valGap: (calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value') - offerVal),
                valGapPct: ((calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value') - offerVal) / offerVal * 100)
            }));

            // Sort
            if (sortBy === 'tqs')    candidates.sort((a,b) => b.tqs - a.tqs);
            else if (sortBy === 'demand') candidates.sort((a,b) => b.pet.d - a.pet.d);
            else if (sortBy === 'value')  candidates.sort((a,b) => b.valGapPct - a.valGapPct);

            candidates = candidates.slice(0, 20);

            if (candidates.length === 0) {
                resultsEl.innerHTML = '<div class="advisor-empty">No pets match your current filters. Try widening the value window or lowering the demand filter.</div>';
                return;
            }

            const demTierLabel = offerAvgD >= 7 ? 'High' : offerAvgD >= 4 ? 'Mid' : 'Low';
            resultsEl.innerHTML = candidates.map(({pet: t, tqs, valGapPct}) => {
                const catLabel = getCatLabel(t);
                const catBadge = catLabel === 'High Tier' ? 'badge-hightier' : catLabel === 'Preppy' ? 'badge-preppy' : catLabel === 'Exotic' ? 'badge-exotic' : 'badge-randoms';
                const tqsCls = tqs >= 7 ? 'high' : tqs >= 4 ? 'mid' : 'low';
                const tqsLabel = tqs >= 7 ? 'üî• Strong Trade' : tqs >= 4 ? '„ÄΩÔ∏è Decent Trade' : '‚ö†Ô∏è Weak Trade';
                const ugly = isHTT(t.n), manip = !!getManipulationFlag(t.n);
                const isRising = t.vt && t.vt.includes('üìà'), isFalling = t.dt && t.dt.includes('‚ùÑÔ∏è');
                const valColor = valGapPct >= 0 ? 'var(--win)' : 'var(--lose)';
                const reason = buildReasonText(t, offerVal, offerAvgD);
                const tVal = calculatePetVal({...t,type:'reg',f_st:false,r_st:false},'value');

                return `<div class="target-card">
                    ${petImgTag(t.n, "width:58px;height:58px;object-fit:contain;border-radius:10px;background:#0f172a")}
                    <div class="target-card-body">
                        <div class="target-name">${t.n}</div>
                        <div class="target-badges">
                            <span class="target-badge ${catBadge}">${catLabel}</span>
                            ${isRising ? '<span class="target-badge badge-rising">üìà Rising</span>' : ''}
                            ${isFalling ? '<span class="target-badge badge-falling">‚ùÑÔ∏è Falling</span>' : ''}
                            ${ugly ? '<span class="target-badge badge-ugly">‚ö†Ô∏è HTT</span>' : ''}
                            ${manip ? '<span class="target-badge badge-manip">üìä Value Spike</span>' : ''}
                        </div>
                        <div class="target-reason">${reason}</div>
                        <div class="target-meta">
                            <span class="tqs-badge tqs-${tqsCls}">${tqsLabel} ${tqs.toFixed(1)}/10</span>
                            <span class="target-val-gap" style="color:${valColor}">${valGapPct>=0?'+':''}${valGapPct.toFixed(1)}%</span>
                            <span class="target-demand-pill">Dem: ${t.d}</span>
                            <span class="target-val-gap">Val: ${tVal.toFixed(2)}</span>
                        </div>
                    </div>
                </div>`;
            }).join('');

            // Insight bar
            const topCat = candidates.slice(0,5).reduce((acc, {pet}) => {
                const c = getCatLabel(pet); acc[c] = (acc[c]||0)+1; return acc;
            }, {});
            const bestCat = Object.entries(topCat).sort((a,b)=>b[1]-a[1])[0]?.[0] || 'mixed';
            const demAdvice = offerAvgD < 4
                ? 'Your offer has low average demand. Prioritise trading into higher-demand pets ‚Äî even a slight value loss is worth it to gain liquidity.'
                : offerAvgD >= 7 ? 'Strong demand offer. You have leverage ‚Äî aim for value gain + category upgrade.'
                : 'Moderate demand offer. Look for targets with demand 6+ to improve your trading velocity.';
            insightEl.innerHTML = `<strong>Your offer: ${offerVal.toFixed(2)} value ¬∑ ${demTierLabel} demand (${offerAvgD.toFixed(1)})</strong><br>${demAdvice} Best target category in range: <strong>${bestCat}</strong>.`;
        }


        // ================================================================
        // SETTINGS ‚Äî UI Scale + Pet Keybinds
        // ================================================================
        let capturingKeyForIndex = -1;
        let capturedKey = '';

        // ‚îÄ‚îÄ AI STRATEGIST FULLSCREEN ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
        function openAIFullscreen() {
            attachAIOverlayListeners();
            const overlay = document.getElementById('aiFullscreenOverlay');
            overlay.classList.add('open');
            // Sync controls from main panel to fullscreen
            const mode = state.aiMode || 'normal';
            document.getElementById('fsAiTogNormal').classList.toggle('active', mode === 'normal');
            document.getElementById('fsAiTogVelocity').classList.toggle('active', mode === 'velocity');
            document.getElementById('fsStrategyCountSlider').value = state.strategyLimit || 10;
            document.getElementById('fsStrategyCountVal').textContent = state.strategyLimit || 10;
            // Sync dream pet display
            const dc = document.getElementById('fsDreamPetContainer');
            if (state.dreamPet) {
                dc.innerHTML = `<div class="dream-active-badge"><span>Target: ${state.dreamPet.n}</span><span style="cursor:pointer" onclick="clearDreamPetFS()">‚úï</span></div>`;
            } else {
                dc.innerHTML = `<button class="nav-btn" style="width:100%;font-size:0.8em;padding:8px" onclick="openSearch('dream')">‚òÖ Set Dream Pet</button>`;
            }
            refreshAIFullscreen();
        }

        function closeAIFullscreen() {
            document.getElementById('aiFullscreenOverlay').classList.remove('open');
        }

        function refreshAIFullscreen() {
            // Render AI suggestions into the fullscreen body
            const origBox = document.getElementById('aiSuggestions');
            const fsBox   = document.getElementById('aiFullscreenBody');
            // Temporarily swap the target element, run the update, swap back
            const origParent = origBox.parentNode;
            fsBox.innerHTML = '<div class="ai-suggestion" style="text-align:center;color:var(--subtext)">Generating...</div>';
            // Use a fake box trick: clone the content after updateAISuggestions runs
            updateAISuggestions(state.inv);
            fsBox.innerHTML = origBox.innerHTML;
        }

        function setAiStrategyFS(mode) {
            setAiStrategy(mode);
            document.getElementById('fsAiTogNormal').classList.toggle('active', mode === 'normal');
            document.getElementById('fsAiTogVelocity').classList.toggle('active', mode === 'velocity');
            refreshAIFullscreen();
        }

        function updateStrategyCountFS(val) {
            updateStrategyCount(val);
            document.getElementById('fsStrategyCountVal').textContent = val;
            refreshAIFullscreen();
        }

        function setAIFullscreenZoom(val) {
            const body = document.getElementById('aiFullscreenBody');
            if (body) body.style.fontSize = (val / 100) + 'em';
            const lbl = document.getElementById('fsAiZoomLabel');
            if (lbl) lbl.textContent = val + '%';
        }

        function clearDreamPetFS() {
            clearDreamPet();
            document.getElementById('fsDreamPetContainer').innerHTML =
                `<button class="nav-btn" style="width:100%;font-size:0.8em;padding:8px" onclick="openSearch('dream')">‚òÖ Set Dream Pet</button>`;
            refreshAIFullscreen();
        }

        // Close on backdrop click + Escape ‚Äî wired up lazily on first open
        let aiOverlayListenersAttached = false;
        function attachAIOverlayListeners() {
            if (aiOverlayListenersAttached) return;
            aiOverlayListenersAttached = true;
            const overlay = document.getElementById('aiFullscreenOverlay');
            if (!overlay) return;
            overlay.addEventListener('click', function(e) {
                if (e.target === this) closeAIFullscreen();
            });
            document.addEventListener('keydown', function(e) {
                if (e.key === 'Escape' && document.getElementById('aiFullscreenOverlay').classList.contains('open')) {
                    closeAIFullscreen();
                }
            });
        }

        function openSettings() {
            document.getElementById('settingsOverlay').style.display = 'flex';
            renderKeybindList();
            document.getElementById('uiScaleSlider').value = Math.round(state.uiScale * 100);
            document.getElementById('uiScaleLabel').textContent = Math.round(state.uiScale * 100) + '%';
        }

        function closeSettings() {
            document.getElementById('settingsOverlay').style.display = 'none';
        }

        function applyUIScale(val) {
            const pct = parseInt(val);
            state.uiScale = pct / 100;
            document.documentElement.style.fontSize = state.uiScale + 'em';
            document.getElementById('uiScaleSlider').value = pct;
            document.getElementById('uiScaleLabel').textContent = pct + '%';
        }

        function addKeybind() {
            state.keybinds.push({ key: '?', petName: '', source: 'inv', type: 'reg', f_st: false, r_st: false });
            renderKeybindList();
        }

        function removeKeybind(idx) {
            state.keybinds.splice(idx, 1);
            renderKeybindList();
        }

        function setKeybindPet(idx, petName) {
            state.keybinds[idx].petName = petName;
        }

        function setKeybindSource(idx, source) {
            state.keybinds[idx].source = source;
            state.keybinds[idx].petName = '';
            renderKeybindList();
        }

        function startKeyCapture(idx) {
            capturingKeyForIndex = idx;
            capturedKey = '';
            document.getElementById('keyCaptureDisplay').textContent = 'Waiting...';
            document.getElementById('keyCaptureConfirm').disabled = true;
            document.getElementById('keyCaptureOverlay').style.display = 'flex';
        }

        function cancelKeyCapture() {
            capturingKeyForIndex = -1;
            capturedKey = '';
            document.getElementById('keyCaptureOverlay').style.display = 'none';
        }

        function confirmKeyCapture() {
            if (capturingKeyForIndex >= 0 && capturedKey) {
                // Check for conflicts
                const conflict = state.keybinds.findIndex((b, i) => i !== capturingKeyForIndex && b.key === capturedKey);
                if (conflict >= 0) {
                    alert(`Key "${capturedKey}" is already used by another keybind. Remove it first.`);
                    return;
                }
                state.keybinds[capturingKeyForIndex].key = capturedKey;
                renderKeybindList();
            }
            cancelKeyCapture();
        }

        document.addEventListener('keydown', (e) => {
            if (document.getElementById('keyCaptureOverlay').style.display === 'flex') {
                e.preventDefault();
                e.stopPropagation();
                if (['Control','Alt','Shift','Meta'].includes(e.key)) return;
                capturedKey = e.key.length === 1 ? e.key.toUpperCase() : e.key;
                document.getElementById('keyCaptureDisplay').textContent = capturedKey;
                document.getElementById('keyCaptureConfirm').disabled = false;
            }
        }, true); // capture phase so it fires before the global listener

        function renderKeybindList() {
            const el = document.getElementById('keybindList');
            if (!el) return;
            if (state.keybinds.length === 0) {
                el.innerHTML = '<div style="text-align:center;color:var(--subtext);font-size:0.8em;padding:10px">No keybinds set. Click Add New Keybind to create one.</div>';
                return;
            }
            el.innerHTML = state.keybinds.map((b, i) => {
                // Build pet list based on source
                const pets = b.source === 'inv'
                    ? state.inv.map(p => p.n).filter((v,idx,a)=>a.indexOf(v)===idx)
                    : ALL_PETS.map(p => p.n);
                const petOptions = pets.length === 0
                    ? '<option value="">-- empty inventory --</option>'
                    : '<option value="">-- pick pet --</option>' + pets.map(n => `<option value="${n.replace(/"/g,'&quot;')}" ${b.petName===n?'selected':''}>${n}</option>`).join('');

                return `<div class="keybind-row">
                    <div class="keybind-key" title="Click to change key" onclick="startKeyCapture(${i})">${b.key || '?'}</div>
                    <div class="keybind-source-toggle">
                        <button class="ks-tog ${b.source==='inv'?'active':''}" onclick="setKeybindSource(${i},'inv')">Inv</button>
                        <button class="ks-tog ${b.source==='all'?'active':''}" onclick="setKeybindSource(${i},'all')">All</button>
                    </div>
                    <select class="keybind-select" onchange="setKeybindPet(${i},this.value)">${petOptions}</select>
                    <button class="keybind-remove" onclick="removeKeybind(${i})">‚úï</button>
                </div>`;
            }).join('');
        }


        // ================================================================
        // TAB SYSTEM + VALUE LIST + DEMAND LIST
        // ================================================================
        let currentTab = 'calc';

        function switchTab(tab) {
            currentTab = tab;
            ['value','demand','calc'].forEach(t => {
                document.getElementById('tab' + t.charAt(0).toUpperCase() + t.slice(1)).classList.toggle('active', t === tab);
                document.getElementById('tabBtn' + t.charAt(0).toUpperCase() + t.slice(1)).classList.toggle('active', t === tab);
            });
            if (tab === 'value' && ALL_PETS.length > 0) renderValueList();
            if (tab === 'demand' && ALL_PETS.length > 0) renderDemandList();
        }

        // List state ‚Äî type and zoom are independent per list
        const listState = {
            value:  { type: 'normal', zoom: 46 },
            demand: { type: 'normal', zoom: 46, increment: 0.1 }
        };

        function setVListType(list, type) {
            listState[list].type = type;
            // Update toggle buttons
            const prefix = list === 'value' ? 'v' : 'd';
            ['Normal','Neon','Mega'].forEach(t => {
                const id = prefix + 'Type' + t;
                const el = document.getElementById(id);
                if (el) el.classList.toggle('active', t.toLowerCase() === type || (t === 'Mega' && type === 'mega'));
            });
            if (list === 'value') renderValueList();
            else renderDemandList();
        }

        function setListZoom(list, val) {
            listState[list].zoom = parseInt(val);
            if (list === 'value') renderValueList();
            else renderDemandList();
        }

        function setDemandIncrement(inc) {
            listState.demand.increment = inc;
            // Update button active states
            document.getElementById('dInc01').classList.toggle('active', inc === 0.1);
            document.getElementById('dInc05').classList.toggle('active', inc === 0.5);
            document.getElementById('dInc1').classList.toggle('active',  inc === 1);
            renderDemandList();
        }

        // Get the correct value for a pet based on list type
        function getPetListValue(p, type) {
            if (type === 'neon')  return parseFloat(p.nfr_v || p.n_v || p.v) || 0;
            if (type === 'mega')  return parseFloat(p.mfr_v || p.m_v || p.v) || 0;
            return parseFloat(p.v) || 0;
        }

        // Get demand for a pet based on type
        function getPetListDemand(p, type) {
            if (type === 'neon')  return parseFloat(p.nd || p.d) || 0;
            if (type === 'mega')  return parseFloat(p.md || p.d) || 0;
            return parseFloat(p.d) || 0;
        }

        function getTypeLabel(type) {
            if (type === 'neon') return 'NFR';
            if (type === 'mega') return 'MFR';
            return '';
        }

        function renderValueList() {
            const body = document.getElementById('valueListBody');
            const search = (document.getElementById('valueListSearch').value || '').toLowerCase();
            if (ALL_PETS.length === 0) { body.innerHTML = '<div style="text-align:center;color:var(--subtext);padding:40px">Loading data...</div>'; return; }

            const { type, zoom } = listState.value;
            const imgSize = zoom;
            const tileSize = zoom + 10;
            const typeLabel = getTypeLabel(type);

            let pets = ALL_PETS.filter(p => !search || p.n.toLowerCase().includes(search));

            // For neon/mega, filter out pets with no value for that type AND eggs (eggs don't have neon/mega)
            if (type === 'neon')  pets = pets.filter(p => !isEgg(p.n) && parseFloat(p.nfr_v || p.n_v) > 0);
            if (type === 'mega')  pets = pets.filter(p => !isEgg(p.n) && parseFloat(p.mfr_v || p.m_v) > 0);

            const groups = {};
            pets.forEach(p => {
                const v = getPetListValue(p, type);
                if (v <= 0) return;
                let tier;
                if (v >= 1000) tier = Math.round(v / 100) * 100;
                else if (v >= 100) tier = Math.round(v / 10) * 10;
                else if (v >= 10)  tier = Math.round(v);
                else if (v >= 1)   tier = Math.round(v * 2) / 2;
                else               tier = Math.round(v * 100) / 100;
                const key = tier.toString();
                if (!groups[key]) groups[key] = { tier, pets: [] };
                groups[key].pets.push(p);
            });

            const sorted = Object.values(groups).sort((a,b) => b.tier - a.tier);
            if (sorted.length === 0) {
                body.innerHTML = '<div style="text-align:center;color:var(--subtext);padding:40px">No pets found for this type.</div>';
                return;
            }

            body.innerHTML = sorted.map(g => `
                <div class="vlist-tier-row">
                    <div class="vlist-tier-label">${g.tier >= 1 ? g.tier : g.tier.toFixed(2)}</div>
                    <div class="vlist-pets">
                        ${g.pets.sort((a,b) => getPetListValue(b,type) - getPetListValue(a,type)).map(p => {
                            const val = getPetListValue(p, type);
                            const safeN = p.n.replace(/'/g,"\'");
                            return `<div class="vlist-pet" style="width:${tileSize}px;height:${tileSize}px" onclick="quickAddFromList('${safeN}','${type}')">
                                ${petImgTag(p.n, 'width:'+imgSize+'px;height:'+imgSize+'px;object-fit:contain')}
                                <div class="vlist-pet-tooltip">${typeLabel ? typeLabel+' ' : ''}${p.n} ¬∑ ${val}</div>
                            </div>`;
                        }).join('')}
                    </div>
                </div>
            `).join('');
        }

        function renderDemandList() {
            const body = document.getElementById('demandListBody');
            const search = (document.getElementById('demandListSearch').value || '').toLowerCase();
            if (ALL_PETS.length === 0) { body.innerHTML = '<div style="text-align:center;color:var(--subtext);padding:40px">Loading data...</div>'; return; }

            const { type, zoom, increment } = listState.demand;
            const inc = increment || 0.1;
            const imgSize = zoom;
            const tileSize = zoom + 10;
            const typeLabel = getTypeLabel(type);

            let allFiltered = ALL_PETS.filter(p => !search || p.n.toLowerCase().includes(search));

            // Eggs only show in Normal tab
            if (type === 'neon')  allFiltered = allFiltered.filter(p => !isEgg(p.n) && parseFloat(p.nfr_v || p.n_v) > 0);
            if (type === 'mega')  allFiltered = allFiltered.filter(p => !isEgg(p.n) && parseFloat(p.mfr_v || p.m_v) > 0);

            // Separate artifact demand pets from normal grouped pets
            const artifactPets = allFiltered.filter(p => ARTIFACT_DEMAND_PETS.has(p.n.toLowerCase().trim()));
            const normalPets   = allFiltered.filter(p => !ARTIFACT_DEMAND_PETS.has(p.n.toLowerCase().trim()));

            const groups = {};
            normalPets.forEach(p => {
                const d = getPetListDemand(p, type);
                // Bucket by chosen increment
                const factor = Math.round(1 / inc);
                const bucket = Math.round(d * factor) / factor;
                const decimals = inc < 1 ? (inc === 0.1 ? 1 : 1) : 0;
                const key = bucket.toFixed(decimals);
                if (!groups[key]) groups[key] = { d: bucket, pets: [] };
                groups[key].pets.push(p);
            });

            const sorted = Object.values(groups).sort((a,b) => b.d - a.d);

            // Build artifact row HTML
            let artifactRowHtml = '';
            if (artifactPets.length > 0 && type === 'normal') {
                artifactRowHtml = `<div class="vlist-tier-row" style="border-bottom:1.5px solid #7c3aed44;margin-bottom:14px;padding-bottom:14px">
                    <div class="vlist-tier-label" style="color:#a855f7;font-size:0.65em;line-height:1.3">‚ú®<br>Artifact<br>Demand</div>
                    <div class="vlist-pets">
                        ${artifactPets.map(p => {
                            const safeN = p.n.replace(/'/g,"\'");
                            return `<div class="vlist-pet" style="width:${tileSize}px;height:${tileSize}px;border-color:#7c3aed88" onclick="quickAddFromList('${safeN}','${type}')">
                                ${petImgTag(p.n, 'width:'+imgSize+'px;height:'+imgSize+'px;object-fit:contain')}
                                <div class="vlist-pet-tooltip" style="border-color:#a855f7">${p.n} ¬∑ ‚ú® Artifact Demand</div>
                            </div>`;
                        }).join('')}
                    </div>
                </div>`;
            }

            if (sorted.length === 0 && !artifactRowHtml) {
                body.innerHTML = '<div style="text-align:center;color:var(--subtext);padding:40px">No pets found for this type.</div>';
                return;
            }

            const groupsHtml = sorted.map(g => {
                const color = getDemandColor(g.d);
                const dDecimals = inc < 1 ? 1 : 0;
                const dStr = g.d.toFixed(dDecimals);
                const label = g.d >= 9 ? 'üî• ' + dStr : g.d >= 7 ? '‚ö° ' + dStr : g.d <= 2 ? '‚ùÑÔ∏è ' + dStr : dStr;
                return `<div class="vlist-tier-row">
                    <div class="vlist-tier-label" style="color:${color}">${label}</div>
                    <div class="vlist-pets">
                        ${g.pets.sort((a,b) => getPetListValue(b,'normal') - getPetListValue(a,'normal')).map(p => {
                            const dem = getPetListDemand(p, type);
                            const safeN = p.n.replace(/'/g,"\'");
                            return `<div class="vlist-pet" style="width:${tileSize}px;height:${tileSize}px;border-color:${color}33" onclick="quickAddFromList('${safeN}','${type}')">
                                ${petImgTag(p.n, 'width:'+imgSize+'px;height:'+imgSize+'px;object-fit:contain')}
                                <div class="vlist-pet-tooltip" style="border-color:${color}">${typeLabel ? typeLabel+' ' : ''}${p.n} ¬∑ Dem ${dem}</div>
                            </div>`;
                        }).join('')}
                    </div>
                </div>`;
            }).join('');

            body.innerHTML = artifactRowHtml + groupsHtml;
        }

        // Click a pet on the value/demand list ‚Üí add to Side A, switch to calc tab
        // Respects the type selected (adds as neon/mega if that type is active)
        function quickAddFromList(petName, type) {
            const pet = ALL_PETS.find(p => p.n === petName);
            if (!pet) return;
            pushState();
            const petType = (type === 'neon') ? 'neon' : (type === 'mega') ? 'mega' : 'reg';
            const isFR = (type === 'neon' || type === 'mega'); // NFR/MFR = fly+ride
            state.A.push({ ...pet, uid: Date.now() + Math.random(), type: petType, f_st: isFR, r_st: isFR });
            switchTab('calc');
            render();
            saveTrade();
        }



        // ================================================================
        // IMAGE OVERRIDES ‚Äî for items AMVGG doesn't host (potions, etc.)
        // Add any pet name (lowercase) ‚Üí image URL here
        // Uses inline SVG data URIs so they ALWAYS work, no CDN needed
        // ================================================================
        const IMAGE_OVERRIDES = {
            'ride-a-pet potion': 'https://static.wikia.nocookie.net/adoptme/images/3/30/AM_Ride-A-Pet_Potion.png/revision/latest?cb=20220427134837',
            'fly-a-pet potion':  'https://static.wikia.nocookie.net/adoptme/images/2/2a/Fly-A-Pet_Potion.png/revision/latest?cb=20231206204208',
        };

        // Pets with "Artifact Demand" ‚Äî custom demand tier you created
        // Shown separately in demand list, excluded from normal demand groups
        const ARTIFACT_DEMAND_PETS = new Set([
            'ride-a-pet potion',
            'fly-a-pet potion',
        ]);

        // Returns true if this pet is an egg (should only show in Normal type)
        function isEgg(name) {
            const n = (name || '').toLowerCase();
            return n.includes(' egg') || n.endsWith('egg') || n === 'egg';
        }

        // ================================================================
        // SMART IMAGE LOADER ‚Äî tries multiple name variants
        // AMVGG filenames often differ in capitalisation from CSV names
        // e.g. "ride-a-pet potion" ‚Üí "Ride-A-Pet Potion"
        // ================================================================
        function toTitleCase(str) {
            return str.replace(/([^\s\-])[^\s\-]*/g, (w, first) => first.toUpperCase() + w.slice(1).toLowerCase());
        }

        // Strip accents/diacritics: Ti√≥ ‚Üí Tio, √© ‚Üí e, √± ‚Üí n etc.
        function stripAccents(str) {
            return str.normalize('NFD').replace(/[\u0300-\u036f]/g, '');
        }

        // Normalise special characters that AMVGG may strip or replace
        // e.g. apostrophes, periods, colons, ampersands etc.
        function stripSpecialChars(str) {
            return str
                .replace(/[''`¬¥]/g, '')          // apostrophes / smart quotes ‚Üí remove
                .replace(/\.+/g, '')              // periods ‚Üí remove
                .replace(/&/g, 'and')              // & ‚Üí and
                .replace(/[^a-zA-Z0-9\s\-√©√®√™√´√†√¢√Æ√Ø√π√ª√º√¥≈ì√¶√ß√±√£√µ√â√à√ä√ã√Ä√Ç√é√è√ô√õ√ú√î≈í√Ü√á√ë√É√ï]/g, '') // remove anything else unusual
                .replace(/\s{2,}/g, ' ')           // collapse double spaces
                .trim();
        }

        function getPetImageVariants(name) {
            const variants = new Set();
            const accStripped  = stripAccents(name);
            const specStripped = stripSpecialChars(name);
            const bothStripped = stripSpecialChars(stripAccents(name));

            // Build a set of base strings ‚Äî original + each normalisation combo
            const bases = new Set([name, accStripped, specStripped, bothStripped]);

            bases.forEach(base => {
                if (!base) return;
                variants.add(base);                                           // as-is
                variants.add(toTitleCase(base));                              // Title Case
                variants.add(base.charAt(0).toUpperCase() + base.slice(1));  // Sentence case
                variants.add(base.toLowerCase());                             // lowercase
                // Capitalise after hyphens and spaces
                variants.add(base.replace(/(^|[\s\-])([a-z])/g, (_, sep, c) => sep + c.toUpperCase()));
                // Spaces ‚Üî hyphens
                variants.add(base.replace(/\s+/g, '-'));
                variants.add(toTitleCase(base).replace(/\s+/g, '-'));
                variants.add(base.replace(/-/g, ' '));
                variants.add(toTitleCase(base.replace(/-/g, ' ')));
            });

            return [...variants].filter(Boolean);
        }

        // Build an img element with smart fallback chain
        // Returns an <img> tag string for use in innerHTML
        function petImgTag(name, style) {
            const styleAttr = style || 'width:36px;height:36px;object-fit:contain';
            const key = (name || '').toLowerCase().trim();

            // Check hardcoded overrides first ‚Äî for items AMVGG doesn't host
            if (IMAGE_OVERRIDES[key]) {
                return `<img src="${IMAGE_OVERRIDES[key]}" style="${styleAttr}" alt="${name.replace(/"/g,'&quot;')}">`;
            }

            const variants = getPetImageVariants(name);
            const firstSrc = 'https://amvgg.com/items/' + encodeURIComponent(variants[0]) + '.webp';
            const fallbacks = JSON.stringify(variants.slice(1).map(v => 'https://amvgg.com/items/' + encodeURIComponent(v) + '.webp'));
            return `<img src="${firstSrc}" style="${styleAttr}" loading="lazy"
                data-fallbacks='${fallbacks}' data-fb-idx="0"
                onerror="petImgFallback(this)"
                alt="${name.replace(/"/g,'&quot;')}">`;
        }

        function petImgFallback(img) {
            try {
                const fallbacks = JSON.parse(img.dataset.fallbacks || '[]');
                let idx = parseInt(img.dataset.fbIdx || '0');
                idx++;
                if (idx < fallbacks.length) {
                    img.dataset.fbIdx = idx;
                    img.src = fallbacks[idx];
                } else {
                    // All variants exhausted ‚Äî use placeholder
                    img.onerror = null;
                    img.src = 'https://amvgg.com/items/theme-color.webp';
                }
            } catch(e) {
                img.onerror = null;
                img.src = 'https://amvgg.com/items/theme-color.webp';
            }
        }

        loadPetData();
    </script>
    <div id="verdictExtras" class="verdict-extras"></div>

    <!-- AI STRATEGIST FULLSCREEN OVERLAY -->
    <div id="aiFullscreenOverlay">
        <div id="aiFullscreenInner">
            <div class="ai-title" style="margin-bottom:0">
                <span>ü§ñ AI Strategist</span>
                <div style="display:flex;gap:6px;align-items:center">
                    <button class="ai-refresh-btn" onclick="refreshAIFullscreen()">Refresh ‚Üª</button>
                    <button class="ai-fullscreen-btn" onclick="closeAIFullscreen()">‚úï Close</button>
                </div>
            </div>
            <!-- Mirror all controls -->
            <div class="ai-toggle-group" style="margin-top:12px">
                <div class="ai-tog" id="fsAiTogNormal" onclick="setAiStrategyFS('normal')">Normal Mode</div>
                <div class="ai-tog" id="fsAiTogVelocity" onclick="setAiStrategyFS('velocity')">Velocity Mode</div>
            </div>
            <div id="fsDreamPetContainer" style="margin-bottom:12px"></div>
            <div style="display:flex;gap:12px;align-items:center;flex-wrap:wrap;margin-bottom:12px">
                <div class="ai-count-control" style="margin-bottom:0;flex:1;min-width:140px">
                    <label>Strategy Count: <span id="fsStrategyCountVal">10</span></label>
                    <input type="range" id="fsStrategyCountSlider" min="1" max="10" value="10" oninput="updateStrategyCountFS(this.value)">
                </div>
                <div style="display:flex;align-items:center;gap:7px;background:var(--panel);border:1.5px solid var(--accent);border-radius:8px;padding:5px 11px;flex-shrink:0">
                    <span style="font-size:0.75em;color:var(--accent);font-weight:900;white-space:nowrap">üîç Zoom</span>
                    <input type="range" id="fsAiZoom" min="70" max="150" value="100"
                        oninput="setAIFullscreenZoom(this.value)"
                        style="width:90px;accent-color:var(--accent);cursor:pointer">
                    <span id="fsAiZoomLabel" style="font-size:0.72em;color:var(--accent);font-weight:800;min-width:34px">100%</span>
                </div>
            </div>
            <div id="aiFullscreenBody">
                <div class="ai-suggestion">Loading...</div>
            </div>
        </div>
    </div>

</body>
</html>
